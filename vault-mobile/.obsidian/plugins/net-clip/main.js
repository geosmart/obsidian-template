/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@electron/remote/dist/src/renderer/callbacks-registry.js
var require_callbacks_registry = __commonJS({
  "node_modules/@electron/remote/dist/src/renderer/callbacks-registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallbacksRegistry = void 0;
    var CallbacksRegistry = class {
      constructor() {
        this.nextId = 0;
        this.callbacks = {};
        this.callbackIds = /* @__PURE__ */ new WeakMap();
        this.locationInfo = /* @__PURE__ */ new WeakMap();
      }
      add(callback) {
        let id = this.callbackIds.get(callback);
        if (id != null)
          return id;
        id = this.nextId += 1;
        this.callbacks[id] = callback;
        this.callbackIds.set(callback, id);
        const regexp = /at (.*)/gi;
        const stackString = new Error().stack;
        if (!stackString)
          return id;
        let filenameAndLine;
        let match;
        while ((match = regexp.exec(stackString)) !== null) {
          const location = match[1];
          if (location.includes("(native)"))
            continue;
          if (location.includes("(<anonymous>)"))
            continue;
          if (location.includes("callbacks-registry.js"))
            continue;
          if (location.includes("remote.js"))
            continue;
          if (location.includes("@electron/remote/dist"))
            continue;
          const ref = /([^/^)]*)\)?$/gi.exec(location);
          if (ref)
            filenameAndLine = ref[1];
          break;
        }
        this.locationInfo.set(callback, filenameAndLine);
        return id;
      }
      get(id) {
        return this.callbacks[id] || function() {
        };
      }
      getLocation(callback) {
        return this.locationInfo.get(callback);
      }
      apply(id, ...args) {
        return this.get(id).apply(global, ...args);
      }
      remove(id) {
        const callback = this.callbacks[id];
        if (callback) {
          this.callbackIds.delete(callback);
          delete this.callbacks[id];
        }
      }
    };
    exports.CallbacksRegistry = CallbacksRegistry;
  }
});

// node_modules/@electron/remote/dist/src/common/type-utils.js
var require_type_utils = __commonJS({
  "node_modules/@electron/remote/dist/src/common/type-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserialize = exports.serialize = exports.isSerializableObject = exports.isPromise = void 0;
    var electron_1 = require("electron");
    function isPromise(val) {
      return val && val.then && val.then instanceof Function && val.constructor && val.constructor.reject && val.constructor.reject instanceof Function && val.constructor.resolve && val.constructor.resolve instanceof Function;
    }
    exports.isPromise = isPromise;
    var serializableTypes = [
      Boolean,
      Number,
      String,
      Date,
      Error,
      RegExp,
      ArrayBuffer
    ];
    function isSerializableObject(value) {
      return value === null || ArrayBuffer.isView(value) || serializableTypes.some((type) => value instanceof type);
    }
    exports.isSerializableObject = isSerializableObject;
    var objectMap = function(source, mapper) {
      const sourceEntries = Object.entries(source);
      const targetEntries = sourceEntries.map(([key, val]) => [key, mapper(val)]);
      return Object.fromEntries(targetEntries);
    };
    function serializeNativeImage(image) {
      const representations = [];
      const scaleFactors = image.getScaleFactors();
      if (scaleFactors.length === 1) {
        const scaleFactor = scaleFactors[0];
        const size = image.getSize(scaleFactor);
        const buffer = image.toBitmap({ scaleFactor });
        representations.push({ scaleFactor, size, buffer });
      } else {
        for (const scaleFactor of scaleFactors) {
          const size = image.getSize(scaleFactor);
          const dataURL = image.toDataURL({ scaleFactor });
          representations.push({ scaleFactor, size, dataURL });
        }
      }
      return { __ELECTRON_SERIALIZED_NativeImage__: true, representations };
    }
    function deserializeNativeImage(value) {
      const image = electron_1.nativeImage.createEmpty();
      if (value.representations.length === 1) {
        const { buffer, size, scaleFactor } = value.representations[0];
        const { width, height } = size;
        image.addRepresentation({ buffer, scaleFactor, width, height });
      } else {
        for (const rep of value.representations) {
          const { dataURL, size, scaleFactor } = rep;
          const { width, height } = size;
          image.addRepresentation({ dataURL, scaleFactor, width, height });
        }
      }
      return image;
    }
    function serialize(value) {
      if (value && value.constructor && value.constructor.name === "NativeImage") {
        return serializeNativeImage(value);
      }
      if (Array.isArray(value)) {
        return value.map(serialize);
      } else if (isSerializableObject(value)) {
        return value;
      } else if (value instanceof Object) {
        return objectMap(value, serialize);
      } else {
        return value;
      }
    }
    exports.serialize = serialize;
    function deserialize(value) {
      if (value && value.__ELECTRON_SERIALIZED_NativeImage__) {
        return deserializeNativeImage(value);
      } else if (Array.isArray(value)) {
        return value.map(deserialize);
      } else if (isSerializableObject(value)) {
        return value;
      } else if (value instanceof Object) {
        return objectMap(value, deserialize);
      } else {
        return value;
      }
    }
    exports.deserialize = deserialize;
  }
});

// node_modules/@electron/remote/dist/src/common/get-electron-binding.js
var require_get_electron_binding = __commonJS({
  "node_modules/@electron/remote/dist/src/common/get-electron-binding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElectronBinding = void 0;
    var getElectronBinding = (name) => {
      if (process._linkedBinding) {
        return process._linkedBinding("electron_common_" + name);
      } else if (process.electronBinding) {
        return process.electronBinding(name);
      } else {
        return null;
      }
    };
    exports.getElectronBinding = getElectronBinding;
  }
});

// node_modules/@electron/remote/dist/src/common/module-names.js
var require_module_names = __commonJS({
  "node_modules/@electron/remote/dist/src/common/module-names.js"(exports) {
    "use strict";
    var _a;
    var _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.browserModuleNames = exports.commonModuleNames = void 0;
    var get_electron_binding_1 = require_get_electron_binding();
    exports.commonModuleNames = [
      "clipboard",
      "nativeImage",
      "shell"
    ];
    exports.browserModuleNames = [
      "app",
      "autoUpdater",
      "BaseWindow",
      "BrowserView",
      "BrowserWindow",
      "contentTracing",
      "crashReporter",
      "dialog",
      "globalShortcut",
      "ipcMain",
      "inAppPurchase",
      "Menu",
      "MenuItem",
      "nativeTheme",
      "net",
      "netLog",
      "MessageChannelMain",
      "Notification",
      "powerMonitor",
      "powerSaveBlocker",
      "protocol",
      "pushNotifications",
      "safeStorage",
      "screen",
      "session",
      "ShareMenu",
      "systemPreferences",
      "TopLevelWindow",
      "TouchBar",
      "Tray",
      "utilityProcess",
      "View",
      "webContents",
      "WebContentsView",
      "webFrameMain"
    ].concat(exports.commonModuleNames);
    var features = get_electron_binding_1.getElectronBinding("features");
    if (((_a = features === null || features === void 0 ? void 0 : features.isDesktopCapturerEnabled) === null || _a === void 0 ? void 0 : _a.call(features)) !== false) {
      exports.browserModuleNames.push("desktopCapturer");
    }
    if (((_b = features === null || features === void 0 ? void 0 : features.isViewApiEnabled) === null || _b === void 0 ? void 0 : _b.call(features)) !== false) {
      exports.browserModuleNames.push("ImageView");
    }
  }
});

// node_modules/@electron/remote/dist/src/renderer/remote.js
var require_remote = __commonJS({
  "node_modules/@electron/remote/dist/src/renderer/remote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFunctionWithReturnValue = exports.getGlobal = exports.getCurrentWebContents = exports.getCurrentWindow = exports.getBuiltin = void 0;
    var callbacks_registry_1 = require_callbacks_registry();
    var type_utils_1 = require_type_utils();
    var electron_1 = require("electron");
    var module_names_1 = require_module_names();
    var get_electron_binding_1 = require_get_electron_binding();
    var { Promise: Promise2 } = global;
    var callbacksRegistry = new callbacks_registry_1.CallbacksRegistry();
    var remoteObjectCache = /* @__PURE__ */ new Map();
    var finalizationRegistry = new FinalizationRegistry((id) => {
      const ref = remoteObjectCache.get(id);
      if (ref !== void 0 && ref.deref() === void 0) {
        remoteObjectCache.delete(id);
        electron_1.ipcRenderer.send("REMOTE_BROWSER_DEREFERENCE", contextId, id, 0);
      }
    });
    var electronIds = /* @__PURE__ */ new WeakMap();
    var isReturnValue = /* @__PURE__ */ new WeakSet();
    function getCachedRemoteObject(id) {
      const ref = remoteObjectCache.get(id);
      if (ref !== void 0) {
        const deref = ref.deref();
        if (deref !== void 0)
          return deref;
      }
    }
    function setCachedRemoteObject(id, value) {
      const wr = new WeakRef(value);
      remoteObjectCache.set(id, wr);
      finalizationRegistry.register(value, id);
      return value;
    }
    function getContextId() {
      const v8Util = get_electron_binding_1.getElectronBinding("v8_util");
      if (v8Util) {
        return v8Util.getHiddenValue(global, "contextId");
      } else {
        throw new Error("Electron >=v13.0.0-beta.6 required to support sandboxed renderers");
      }
    }
    var contextId = process.contextId || getContextId();
    process.on("exit", () => {
      const command = "REMOTE_BROWSER_CONTEXT_RELEASE";
      electron_1.ipcRenderer.send(command, contextId);
    });
    var IS_REMOTE_PROXY = Symbol("is-remote-proxy");
    function wrapArgs(args, visited = /* @__PURE__ */ new Set()) {
      const valueToMeta = (value) => {
        if (visited.has(value)) {
          return {
            type: "value",
            value: null
          };
        }
        if (value && value.constructor && value.constructor.name === "NativeImage") {
          return { type: "nativeimage", value: type_utils_1.serialize(value) };
        } else if (Array.isArray(value)) {
          visited.add(value);
          const meta = {
            type: "array",
            value: wrapArgs(value, visited)
          };
          visited.delete(value);
          return meta;
        } else if (value instanceof Buffer) {
          return {
            type: "buffer",
            value
          };
        } else if (type_utils_1.isSerializableObject(value)) {
          return {
            type: "value",
            value
          };
        } else if (typeof value === "object") {
          if (type_utils_1.isPromise(value)) {
            return {
              type: "promise",
              then: valueToMeta(function(onFulfilled, onRejected) {
                value.then(onFulfilled, onRejected);
              })
            };
          } else if (electronIds.has(value)) {
            return {
              type: "remote-object",
              id: electronIds.get(value)
            };
          }
          const meta = {
            type: "object",
            name: value.constructor ? value.constructor.name : "",
            members: []
          };
          visited.add(value);
          for (const prop in value) {
            meta.members.push({
              name: prop,
              value: valueToMeta(value[prop])
            });
          }
          visited.delete(value);
          return meta;
        } else if (typeof value === "function" && isReturnValue.has(value)) {
          return {
            type: "function-with-return-value",
            value: valueToMeta(value())
          };
        } else if (typeof value === "function") {
          return {
            type: "function",
            id: callbacksRegistry.add(value),
            location: callbacksRegistry.getLocation(value),
            length: value.length
          };
        } else {
          return {
            type: "value",
            value
          };
        }
      };
      return args.map(valueToMeta);
    }
    function setObjectMembers(ref, object, metaId, members) {
      if (!Array.isArray(members))
        return;
      for (const member of members) {
        if (Object.prototype.hasOwnProperty.call(object, member.name))
          continue;
        const descriptor = { enumerable: member.enumerable };
        if (member.type === "method") {
          const remoteMemberFunction = function(...args) {
            let command;
            if (this && this.constructor === remoteMemberFunction) {
              command = "REMOTE_BROWSER_MEMBER_CONSTRUCTOR";
            } else {
              command = "REMOTE_BROWSER_MEMBER_CALL";
            }
            const ret = electron_1.ipcRenderer.sendSync(command, contextId, metaId, member.name, wrapArgs(args));
            return metaToValue(ret);
          };
          let descriptorFunction = proxyFunctionProperties(remoteMemberFunction, metaId, member.name);
          descriptor.get = () => {
            descriptorFunction.ref = ref;
            return descriptorFunction;
          };
          descriptor.set = (value) => {
            descriptorFunction = value;
            return value;
          };
          descriptor.configurable = true;
        } else if (member.type === "get") {
          descriptor.get = () => {
            const command = "REMOTE_BROWSER_MEMBER_GET";
            const meta = electron_1.ipcRenderer.sendSync(command, contextId, metaId, member.name);
            return metaToValue(meta);
          };
          if (member.writable) {
            descriptor.set = (value) => {
              const args = wrapArgs([value]);
              const command = "REMOTE_BROWSER_MEMBER_SET";
              const meta = electron_1.ipcRenderer.sendSync(command, contextId, metaId, member.name, args);
              if (meta != null)
                metaToValue(meta);
              return value;
            };
          }
        }
        Object.defineProperty(object, member.name, descriptor);
      }
    }
    function setObjectPrototype(ref, object, metaId, descriptor) {
      if (descriptor === null)
        return;
      const proto = {};
      setObjectMembers(ref, proto, metaId, descriptor.members);
      setObjectPrototype(ref, proto, metaId, descriptor.proto);
      Object.setPrototypeOf(object, proto);
    }
    function proxyFunctionProperties(remoteMemberFunction, metaId, name) {
      let loaded = false;
      const loadRemoteProperties = () => {
        if (loaded)
          return;
        loaded = true;
        const command = "REMOTE_BROWSER_MEMBER_GET";
        const meta = electron_1.ipcRenderer.sendSync(command, contextId, metaId, name);
        setObjectMembers(remoteMemberFunction, remoteMemberFunction, meta.id, meta.members);
      };
      return new Proxy(remoteMemberFunction, {
        set: (target, property, value) => {
          if (property !== "ref")
            loadRemoteProperties();
          target[property] = value;
          return true;
        },
        get: (target, property) => {
          if (property === IS_REMOTE_PROXY)
            return true;
          if (!Object.prototype.hasOwnProperty.call(target, property))
            loadRemoteProperties();
          const value = target[property];
          if (property === "toString" && typeof value === "function") {
            return value.bind(target);
          }
          return value;
        },
        ownKeys: (target) => {
          loadRemoteProperties();
          return Object.getOwnPropertyNames(target);
        },
        getOwnPropertyDescriptor: (target, property) => {
          const descriptor = Object.getOwnPropertyDescriptor(target, property);
          if (descriptor)
            return descriptor;
          loadRemoteProperties();
          return Object.getOwnPropertyDescriptor(target, property);
        }
      });
    }
    function metaToValue(meta) {
      if (!meta)
        return {};
      if (meta.type === "value") {
        return meta.value;
      } else if (meta.type === "array") {
        return meta.members.map((member) => metaToValue(member));
      } else if (meta.type === "nativeimage") {
        return type_utils_1.deserialize(meta.value);
      } else if (meta.type === "buffer") {
        return Buffer.from(meta.value.buffer, meta.value.byteOffset, meta.value.byteLength);
      } else if (meta.type === "promise") {
        return Promise2.resolve({ then: metaToValue(meta.then) });
      } else if (meta.type === "error") {
        return metaToError(meta);
      } else if (meta.type === "exception") {
        if (meta.value.type === "error") {
          throw metaToError(meta.value);
        } else {
          throw new Error(`Unexpected value type in exception: ${meta.value.type}`);
        }
      } else {
        let ret;
        if ("id" in meta) {
          const cached = getCachedRemoteObject(meta.id);
          if (cached !== void 0) {
            return cached;
          }
        }
        if (meta.type === "function") {
          const remoteFunction = function(...args) {
            let command;
            if (this && this.constructor === remoteFunction) {
              command = "REMOTE_BROWSER_CONSTRUCTOR";
            } else {
              command = "REMOTE_BROWSER_FUNCTION_CALL";
            }
            const obj = electron_1.ipcRenderer.sendSync(command, contextId, meta.id, wrapArgs(args));
            return metaToValue(obj);
          };
          ret = remoteFunction;
        } else {
          ret = {};
        }
        setObjectMembers(ret, ret, meta.id, meta.members);
        setObjectPrototype(ret, ret, meta.id, meta.proto);
        if (ret.constructor && ret.constructor[IS_REMOTE_PROXY]) {
          Object.defineProperty(ret.constructor, "name", { value: meta.name });
        }
        electronIds.set(ret, meta.id);
        setCachedRemoteObject(meta.id, ret);
        return ret;
      }
    }
    function metaToError(meta) {
      const obj = meta.value;
      for (const { name, value } of meta.members) {
        obj[name] = metaToValue(value);
      }
      return obj;
    }
    function hasSenderId(input) {
      return typeof input.senderId === "number";
    }
    function handleMessage(channel, handler) {
      electron_1.ipcRenderer.on(channel, (event, passedContextId, id, ...args) => {
        if (hasSenderId(event)) {
          if (event.senderId !== 0 && event.senderId !== void 0) {
            console.error(`Message ${channel} sent by unexpected WebContents (${event.senderId})`);
            return;
          }
        }
        if (passedContextId === contextId) {
          handler(id, ...args);
        } else {
          electron_1.ipcRenderer.send("REMOTE_BROWSER_WRONG_CONTEXT_ERROR", contextId, passedContextId, id);
        }
      });
    }
    var enableStacks = process.argv.includes("--enable-api-filtering-logging");
    function getCurrentStack() {
      const target = { stack: void 0 };
      if (enableStacks) {
        Error.captureStackTrace(target, getCurrentStack);
      }
      return target.stack;
    }
    handleMessage("REMOTE_RENDERER_CALLBACK", (id, args) => {
      callbacksRegistry.apply(id, metaToValue(args));
    });
    handleMessage("REMOTE_RENDERER_RELEASE_CALLBACK", (id) => {
      callbacksRegistry.remove(id);
    });
    exports.require = (module3) => {
      const command = "REMOTE_BROWSER_REQUIRE";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, module3, getCurrentStack());
      return metaToValue(meta);
    };
    function getBuiltin(module3) {
      const command = "REMOTE_BROWSER_GET_BUILTIN";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, module3, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getBuiltin = getBuiltin;
    function getCurrentWindow() {
      const command = "REMOTE_BROWSER_GET_CURRENT_WINDOW";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getCurrentWindow = getCurrentWindow;
    function getCurrentWebContents() {
      const command = "REMOTE_BROWSER_GET_CURRENT_WEB_CONTENTS";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getCurrentWebContents = getCurrentWebContents;
    function getGlobal(name) {
      const command = "REMOTE_BROWSER_GET_GLOBAL";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, name, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getGlobal = getGlobal;
    Object.defineProperty(exports, "process", {
      enumerable: true,
      get: () => exports.getGlobal("process")
    });
    function createFunctionWithReturnValue(returnValue) {
      const func = () => returnValue;
      isReturnValue.add(func);
      return func;
    }
    exports.createFunctionWithReturnValue = createFunctionWithReturnValue;
    var addBuiltinProperty = (name) => {
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: () => exports.getBuiltin(name)
      });
    };
    module_names_1.browserModuleNames.forEach(addBuiltinProperty);
  }
});

// node_modules/@electron/remote/dist/src/renderer/index.js
var require_renderer = __commonJS({
  "node_modules/@electron/remote/dist/src/renderer/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    if (process.type === "browser")
      throw new Error(`"@electron/remote" cannot be required in the browser process. Instead require("@electron/remote/main").`);
    __exportStar(require_remote(), exports);
  }
});

// node_modules/@electron/remote/renderer/index.js
var require_renderer2 = __commonJS({
  "node_modules/@electron/remote/renderer/index.js"(exports, module2) {
    module2.exports = require_renderer();
  }
});

// node_modules/@mozilla/readability/Readability.js
var require_Readability = __commonJS({
  "node_modules/@mozilla/readability/Readability.js"(exports, module2) {
    function Readability2(doc, options) {
      if (options && options.documentElement) {
        doc = options;
        options = arguments[2];
      } else if (!doc || !doc.documentElement) {
        throw new Error(
          "First argument to Readability constructor should be a document object."
        );
      }
      options = options || {};
      this._doc = doc;
      this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;
      this._articleTitle = null;
      this._articleByline = null;
      this._articleDir = null;
      this._articleSiteName = null;
      this._attempts = [];
      this._metadata = {};
      this._debug = !!options.debug;
      this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
      this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
      this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
      this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(
        options.classesToPreserve || []
      );
      this._keepClasses = !!options.keepClasses;
      this._serializer = options.serializer || function(el) {
        return el.innerHTML;
      };
      this._disableJSONLD = !!options.disableJSONLD;
      this._allowedVideoRegex = options.allowedVideoRegex || this.REGEXPS.videos;
      this._linkDensityModifier = options.linkDensityModifier || 0;
      this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY;
      if (this._debug) {
        let logNode = function(node) {
          if (node.nodeType == node.TEXT_NODE) {
            return `${node.nodeName} ("${node.textContent}")`;
          }
          let attrPairs = Array.from(node.attributes || [], function(attr) {
            return `${attr.name}="${attr.value}"`;
          }).join(" ");
          return `<${node.localName} ${attrPairs}>`;
        };
        this.log = function() {
          if (typeof console !== "undefined") {
            let args = Array.from(arguments, (arg) => {
              if (arg && arg.nodeType == this.ELEMENT_NODE) {
                return logNode(arg);
              }
              return arg;
            });
            args.unshift("Reader: (Readability)");
            console.log(...args);
          } else if (typeof dump !== "undefined") {
            var msg = Array.prototype.map.call(arguments, function(x) {
              return x && x.nodeName ? logNode(x) : x;
            }).join(" ");
            dump("Reader: (Readability) " + msg + "\n");
          }
        };
      } else {
        this.log = function() {
        };
      }
    }
    Readability2.prototype = {
      FLAG_STRIP_UNLIKELYS: 1,
      FLAG_WEIGHT_CLASSES: 2,
      FLAG_CLEAN_CONDITIONALLY: 4,
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
      ELEMENT_NODE: 1,
      TEXT_NODE: 3,
      // Max number of nodes supported by this parser. Default: 0 (no limit)
      DEFAULT_MAX_ELEMS_TO_PARSE: 0,
      // The number of top candidates to consider when analysing how
      // tight the competition is among candidates.
      DEFAULT_N_TOP_CANDIDATES: 5,
      // Element tags to score by default.
      DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),
      // The default number of chars an article must have in order to return a result
      DEFAULT_CHAR_THRESHOLD: 500,
      // All of the regular expressions in use within readability.
      // Defined up here so we don't instantiate them repeatedly in loops.
      REGEXPS: {
        // NOTE: These two regular expressions are duplicated in
        // Readability-readerable.js. Please keep both copies in sync.
        unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
        okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,
        positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,
        negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|footer|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|widget/i,
        extraneous: /print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|utility/i,
        byline: /byline|author|dateline|writtenby|p-author/i,
        replaceFonts: /<(\/?)font[^>]*>/gi,
        normalize: /\s{2,}/g,
        videos: /\/\/(www\.)?((dailymotion|youtube|youtube-nocookie|player\.vimeo|v\.qq)\.com|(archive|upload\.wikimedia)\.org|player\.twitch\.tv)/i,
        shareElements: /(\b|_)(share|sharedaddy)(\b|_)/i,
        nextLink: /(next|weiter|continue|>([^\|]|$)|»([^\|]|$))/i,
        prevLink: /(prev|earl|old|new|<|«)/i,
        tokenize: /\W+/g,
        whitespace: /^\s*$/,
        hasContent: /\S$/,
        hashUrl: /^#.+/,
        srcsetUrl: /(\S+)(\s+[\d.]+[xw])?(\s*(?:,|$))/g,
        b64DataUrl: /^data:\s*([^\s;,]+)\s*;\s*base64\s*,/i,
        // Commas as used in Latin, Sindhi, Chinese and various other scripts.
        // see: https://en.wikipedia.org/wiki/Comma#Comma_variants
        commas: /\u002C|\u060C|\uFE50|\uFE10|\uFE11|\u2E41|\u2E34|\u2E32|\uFF0C/g,
        // See: https://schema.org/Article
        jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/,
        // used to see if a node's content matches words commonly used for ad blocks or loading indicators
        adWords: /^(ad(vertising|vertisement)?|pub(licité)?|werb(ung)?|广告|Реклама|Anuncio)$/iu,
        loadingWords: /^((loading|正在加载|Загрузка|chargement|cargando)(…|\.\.\.)?)$/iu
      },
      UNLIKELY_ROLES: [
        "menu",
        "menubar",
        "complementary",
        "navigation",
        "alert",
        "alertdialog",
        "dialog"
      ],
      DIV_TO_P_ELEMS: /* @__PURE__ */ new Set([
        "BLOCKQUOTE",
        "DL",
        "DIV",
        "IMG",
        "OL",
        "P",
        "PRE",
        "TABLE",
        "UL"
      ]),
      ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P", "OL", "UL"],
      PRESENTATIONAL_ATTRIBUTES: [
        "align",
        "background",
        "bgcolor",
        "border",
        "cellpadding",
        "cellspacing",
        "frame",
        "hspace",
        "rules",
        "style",
        "valign",
        "vspace"
      ],
      DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],
      // The commented out elements qualify as phrasing content but tend to be
      // removed by readability when put into paragraphs, so we ignore them here.
      PHRASING_ELEMS: [
        // "CANVAS", "IFRAME", "SVG", "VIDEO",
        "ABBR",
        "AUDIO",
        "B",
        "BDO",
        "BR",
        "BUTTON",
        "CITE",
        "CODE",
        "DATA",
        "DATALIST",
        "DFN",
        "EM",
        "EMBED",
        "I",
        "IMG",
        "INPUT",
        "KBD",
        "LABEL",
        "MARK",
        "MATH",
        "METER",
        "NOSCRIPT",
        "OBJECT",
        "OUTPUT",
        "PROGRESS",
        "Q",
        "RUBY",
        "SAMP",
        "SCRIPT",
        "SELECT",
        "SMALL",
        "SPAN",
        "STRONG",
        "SUB",
        "SUP",
        "TEXTAREA",
        "TIME",
        "VAR",
        "WBR"
      ],
      // These are the classes that readability sets itself.
      CLASSES_TO_PRESERVE: ["page"],
      // These are the list of HTML entities that need to be escaped.
      HTML_ESCAPE_MAP: {
        lt: "<",
        gt: ">",
        amp: "&",
        quot: '"',
        apos: "'"
      },
      /**
       * Run any post-process modifications to article content as necessary.
       *
       * @param Element
       * @return void
       **/
      _postProcessContent(articleContent) {
        this._fixRelativeUris(articleContent);
        this._simplifyNestedElements(articleContent);
        if (!this._keepClasses) {
          this._cleanClasses(articleContent);
        }
      },
      /**
       * Iterates over a NodeList, calls `filterFn` for each node and removes node
       * if function returned `true`.
       *
       * If function is not passed, removes all the nodes in node list.
       *
       * @param NodeList nodeList The nodes to operate on
       * @param Function filterFn the function to use as a filter
       * @return void
       */
      _removeNodes(nodeList, filterFn) {
        if (this._docJSDOMParser && nodeList._isLiveNodeList) {
          throw new Error("Do not pass live node lists to _removeNodes");
        }
        for (var i = nodeList.length - 1; i >= 0; i--) {
          var node = nodeList[i];
          var parentNode = node.parentNode;
          if (parentNode) {
            if (!filterFn || filterFn.call(this, node, i, nodeList)) {
              parentNode.removeChild(node);
            }
          }
        }
      },
      /**
       * Iterates over a NodeList, and calls _setNodeTag for each node.
       *
       * @param NodeList nodeList The nodes to operate on
       * @param String newTagName the new tag name to use
       * @return void
       */
      _replaceNodeTags(nodeList, newTagName) {
        if (this._docJSDOMParser && nodeList._isLiveNodeList) {
          throw new Error("Do not pass live node lists to _replaceNodeTags");
        }
        for (const node of nodeList) {
          this._setNodeTag(node, newTagName);
        }
      },
      /**
       * Iterate over a NodeList, which doesn't natively fully implement the Array
       * interface.
       *
       * For convenience, the current object context is applied to the provided
       * iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return void
       */
      _forEachNode(nodeList, fn) {
        Array.prototype.forEach.call(nodeList, fn, this);
      },
      /**
       * Iterate over a NodeList, and return the first node that passes
       * the supplied test function
       *
       * For convenience, the current object context is applied to the provided
       * test function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The test function.
       * @return void
       */
      _findNode(nodeList, fn) {
        return Array.prototype.find.call(nodeList, fn, this);
      },
      /**
       * Iterate over a NodeList, return true if any of the provided iterate
       * function calls returns true, false otherwise.
       *
       * For convenience, the current object context is applied to the
       * provided iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return Boolean
       */
      _someNode(nodeList, fn) {
        return Array.prototype.some.call(nodeList, fn, this);
      },
      /**
       * Iterate over a NodeList, return true if all of the provided iterate
       * function calls return true, false otherwise.
       *
       * For convenience, the current object context is applied to the
       * provided iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return Boolean
       */
      _everyNode(nodeList, fn) {
        return Array.prototype.every.call(nodeList, fn, this);
      },
      _getAllNodesWithTag(node, tagNames) {
        if (node.querySelectorAll) {
          return node.querySelectorAll(tagNames.join(","));
        }
        return [].concat.apply(
          [],
          tagNames.map(function(tag) {
            var collection = node.getElementsByTagName(tag);
            return Array.isArray(collection) ? collection : Array.from(collection);
          })
        );
      },
      /**
       * Removes the class="" attribute from every element in the given
       * subtree, except those that match CLASSES_TO_PRESERVE and
       * the classesToPreserve array from the options object.
       *
       * @param Element
       * @return void
       */
      _cleanClasses(node) {
        var classesToPreserve = this._classesToPreserve;
        var className = (node.getAttribute("class") || "").split(/\s+/).filter((cls) => classesToPreserve.includes(cls)).join(" ");
        if (className) {
          node.setAttribute("class", className);
        } else {
          node.removeAttribute("class");
        }
        for (node = node.firstElementChild; node; node = node.nextElementSibling) {
          this._cleanClasses(node);
        }
      },
      /**
       * Tests whether a string is a URL or not.
       *
       * @param {string} str The string to test
       * @return {boolean} true if str is a URL, false if not
       */
      _isUrl(str) {
        try {
          new URL(str);
          return true;
        } catch (e) {
          return false;
        }
      },
      /**
       * Converts each <a> and <img> uri in the given element to an absolute URI,
       * ignoring #ref URIs.
       *
       * @param Element
       * @return void
       */
      _fixRelativeUris(articleContent) {
        var baseURI = this._doc.baseURI;
        var documentURI = this._doc.documentURI;
        function toAbsoluteURI(uri) {
          if (baseURI == documentURI && uri.charAt(0) == "#") {
            return uri;
          }
          try {
            return new URL(uri, baseURI).href;
          } catch (ex) {
          }
          return uri;
        }
        var links = this._getAllNodesWithTag(articleContent, ["a"]);
        this._forEachNode(links, function(link) {
          var href = link.getAttribute("href");
          if (href) {
            if (href.indexOf("javascript:") === 0) {
              if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {
                var text = this._doc.createTextNode(link.textContent);
                link.parentNode.replaceChild(text, link);
              } else {
                var container = this._doc.createElement("span");
                while (link.firstChild) {
                  container.appendChild(link.firstChild);
                }
                link.parentNode.replaceChild(container, link);
              }
            } else {
              link.setAttribute("href", toAbsoluteURI(href));
            }
          }
        });
        var medias = this._getAllNodesWithTag(articleContent, [
          "img",
          "picture",
          "figure",
          "video",
          "audio",
          "source"
        ]);
        this._forEachNode(medias, function(media) {
          var src = media.getAttribute("src");
          var poster = media.getAttribute("poster");
          var srcset = media.getAttribute("srcset");
          if (src) {
            media.setAttribute("src", toAbsoluteURI(src));
          }
          if (poster) {
            media.setAttribute("poster", toAbsoluteURI(poster));
          }
          if (srcset) {
            var newSrcset = srcset.replace(
              this.REGEXPS.srcsetUrl,
              function(_, p1, p2, p3) {
                return toAbsoluteURI(p1) + (p2 || "") + p3;
              }
            );
            media.setAttribute("srcset", newSrcset);
          }
        });
      },
      _simplifyNestedElements(articleContent) {
        var node = articleContent;
        while (node) {
          if (node.parentNode && ["DIV", "SECTION"].includes(node.tagName) && !(node.id && node.id.startsWith("readability"))) {
            if (this._isElementWithoutContent(node)) {
              node = this._removeAndGetNext(node);
              continue;
            } else if (this._hasSingleTagInsideElement(node, "DIV") || this._hasSingleTagInsideElement(node, "SECTION")) {
              var child = node.children[0];
              for (var i = 0; i < node.attributes.length; i++) {
                child.setAttributeNode(node.attributes[i].cloneNode());
              }
              node.parentNode.replaceChild(child, node);
              node = child;
              continue;
            }
          }
          node = this._getNextNode(node);
        }
      },
      /**
       * Get the article title as an H1.
       *
       * @return string
       **/
      _getArticleTitle() {
        var doc = this._doc;
        var curTitle = "";
        var origTitle = "";
        try {
          curTitle = origTitle = doc.title.trim();
          if (typeof curTitle !== "string") {
            curTitle = origTitle = this._getInnerText(
              doc.getElementsByTagName("title")[0]
            );
          }
        } catch (e) {
        }
        var titleHadHierarchicalSeparators = false;
        function wordCount(str) {
          return str.split(/\s+/).length;
        }
        if (/ [\|\-\\\/>»] /.test(curTitle)) {
          titleHadHierarchicalSeparators = / [\\\/>»] /.test(curTitle);
          let allSeparators = Array.from(origTitle.matchAll(/ [\|\-\\\/>»] /gi));
          curTitle = origTitle.substring(0, allSeparators.pop().index);
          if (wordCount(curTitle) < 3) {
            curTitle = origTitle.replace(/^[^\|\-\\\/>»]*[\|\-\\\/>»]/gi, "");
          }
        } else if (curTitle.includes(": ")) {
          var headings = this._getAllNodesWithTag(doc, ["h1", "h2"]);
          var trimmedTitle = curTitle.trim();
          var match = this._someNode(headings, function(heading) {
            return heading.textContent.trim() === trimmedTitle;
          });
          if (!match) {
            curTitle = origTitle.substring(origTitle.lastIndexOf(":") + 1);
            if (wordCount(curTitle) < 3) {
              curTitle = origTitle.substring(origTitle.indexOf(":") + 1);
            } else if (wordCount(origTitle.substr(0, origTitle.indexOf(":"))) > 5) {
              curTitle = origTitle;
            }
          }
        } else if (curTitle.length > 150 || curTitle.length < 15) {
          var hOnes = doc.getElementsByTagName("h1");
          if (hOnes.length === 1) {
            curTitle = this._getInnerText(hOnes[0]);
          }
        }
        curTitle = curTitle.trim().replace(this.REGEXPS.normalize, " ");
        var curTitleWordCount = wordCount(curTitle);
        if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\|\-\\\/>»]+/g, "")) - 1)) {
          curTitle = origTitle;
        }
        return curTitle;
      },
      /**
       * Prepare the HTML document for readability to scrape it.
       * This includes things like stripping javascript, CSS, and handling terrible markup.
       *
       * @return void
       **/
      _prepDocument() {
        var doc = this._doc;
        this._removeNodes(this._getAllNodesWithTag(doc, ["style"]));
        if (doc.body) {
          this._replaceBrs(doc.body);
        }
        this._replaceNodeTags(this._getAllNodesWithTag(doc, ["font"]), "SPAN");
      },
      /**
       * Finds the next node, starting from the given node, and ignoring
       * whitespace in between. If the given node is an element, the same node is
       * returned.
       */
      _nextNode(node) {
        var next = node;
        while (next && next.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next.textContent)) {
          next = next.nextSibling;
        }
        return next;
      },
      /**
       * Replaces 2 or more successive <br> elements with a single <p>.
       * Whitespace between <br> elements are ignored. For example:
       *   <div>foo<br>bar<br> <br><br>abc</div>
       * will become:
       *   <div>foo<br>bar<p>abc</p></div>
       */
      _replaceBrs(elem) {
        this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function(br) {
          var next = br.nextSibling;
          var replaced = false;
          while ((next = this._nextNode(next)) && next.tagName == "BR") {
            replaced = true;
            var brSibling = next.nextSibling;
            next.remove();
            next = brSibling;
          }
          if (replaced) {
            var p = this._doc.createElement("p");
            br.parentNode.replaceChild(p, br);
            next = p.nextSibling;
            while (next) {
              if (next.tagName == "BR") {
                var nextElem = this._nextNode(next.nextSibling);
                if (nextElem && nextElem.tagName == "BR") {
                  break;
                }
              }
              if (!this._isPhrasingContent(next)) {
                break;
              }
              var sibling = next.nextSibling;
              p.appendChild(next);
              next = sibling;
            }
            while (p.lastChild && this._isWhitespace(p.lastChild)) {
              p.lastChild.remove();
            }
            if (p.parentNode.tagName === "P") {
              this._setNodeTag(p.parentNode, "DIV");
            }
          }
        });
      },
      _setNodeTag(node, tag) {
        this.log("_setNodeTag", node, tag);
        if (this._docJSDOMParser) {
          node.localName = tag.toLowerCase();
          node.tagName = tag.toUpperCase();
          return node;
        }
        var replacement = node.ownerDocument.createElement(tag);
        while (node.firstChild) {
          replacement.appendChild(node.firstChild);
        }
        node.parentNode.replaceChild(replacement, node);
        if (node.readability) {
          replacement.readability = node.readability;
        }
        for (var i = 0; i < node.attributes.length; i++) {
          replacement.setAttributeNode(node.attributes[i].cloneNode());
        }
        return replacement;
      },
      /**
       * Prepare the article node for display. Clean out any inline styles,
       * iframes, forms, strip extraneous <p> tags, etc.
       *
       * @param Element
       * @return void
       **/
      _prepArticle(articleContent) {
        this._cleanStyles(articleContent);
        this._markDataTables(articleContent);
        this._fixLazyImages(articleContent);
        this._cleanConditionally(articleContent, "form");
        this._cleanConditionally(articleContent, "fieldset");
        this._clean(articleContent, "object");
        this._clean(articleContent, "embed");
        this._clean(articleContent, "footer");
        this._clean(articleContent, "link");
        this._clean(articleContent, "aside");
        var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;
        this._forEachNode(articleContent.children, function(topCandidate) {
          this._cleanMatchedNodes(topCandidate, function(node, matchString) {
            return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;
          });
        });
        this._clean(articleContent, "iframe");
        this._clean(articleContent, "input");
        this._clean(articleContent, "textarea");
        this._clean(articleContent, "select");
        this._clean(articleContent, "button");
        this._cleanHeaders(articleContent);
        this._cleanConditionally(articleContent, "table");
        this._cleanConditionally(articleContent, "ul");
        this._cleanConditionally(articleContent, "div");
        this._replaceNodeTags(
          this._getAllNodesWithTag(articleContent, ["h1"]),
          "h2"
        );
        this._removeNodes(
          this._getAllNodesWithTag(articleContent, ["p"]),
          function(paragraph) {
            var contentElementCount = this._getAllNodesWithTag(paragraph, [
              "img",
              "embed",
              "object",
              "iframe"
            ]).length;
            return contentElementCount === 0 && !this._getInnerText(paragraph, false);
          }
        );
        this._forEachNode(
          this._getAllNodesWithTag(articleContent, ["br"]),
          function(br) {
            var next = this._nextNode(br.nextSibling);
            if (next && next.tagName == "P") {
              br.remove();
            }
          }
        );
        this._forEachNode(
          this._getAllNodesWithTag(articleContent, ["table"]),
          function(table) {
            var tbody = this._hasSingleTagInsideElement(table, "TBODY") ? table.firstElementChild : table;
            if (this._hasSingleTagInsideElement(tbody, "TR")) {
              var row = tbody.firstElementChild;
              if (this._hasSingleTagInsideElement(row, "TD")) {
                var cell = row.firstElementChild;
                cell = this._setNodeTag(
                  cell,
                  this._everyNode(cell.childNodes, this._isPhrasingContent) ? "P" : "DIV"
                );
                table.parentNode.replaceChild(cell, table);
              }
            }
          }
        );
      },
      /**
       * Initialize a node with the readability object. Also checks the
       * className/id for special names to add to its score.
       *
       * @param Element
       * @return void
       **/
      _initializeNode(node) {
        node.readability = { contentScore: 0 };
        switch (node.tagName) {
          case "DIV":
            node.readability.contentScore += 5;
            break;
          case "PRE":
          case "TD":
          case "BLOCKQUOTE":
            node.readability.contentScore += 3;
            break;
          case "ADDRESS":
          case "OL":
          case "UL":
          case "DL":
          case "DD":
          case "DT":
          case "LI":
          case "FORM":
            node.readability.contentScore -= 3;
            break;
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
          case "TH":
            node.readability.contentScore -= 5;
            break;
        }
        node.readability.contentScore += this._getClassWeight(node);
      },
      _removeAndGetNext(node) {
        var nextNode = this._getNextNode(node, true);
        node.remove();
        return nextNode;
      },
      /**
       * Traverse the DOM from node to node, starting at the node passed in.
       * Pass true for the second parameter to indicate this node itself
       * (and its kids) are going away, and we want the next node over.
       *
       * Calling this in a loop will traverse the DOM depth-first.
       *
       * @param {Element} node
       * @param {boolean} ignoreSelfAndKids
       * @return {Element}
       */
      _getNextNode(node, ignoreSelfAndKids) {
        if (!ignoreSelfAndKids && node.firstElementChild) {
          return node.firstElementChild;
        }
        if (node.nextElementSibling) {
          return node.nextElementSibling;
        }
        do {
          node = node.parentNode;
        } while (node && !node.nextElementSibling);
        return node && node.nextElementSibling;
      },
      // compares second text to first one
      // 1 = same text, 0 = completely different text
      // works the way that it splits both texts into words and then finds words that are unique in second text
      // the result is given by the lower length of unique parts
      _textSimilarity(textA, textB) {
        var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
        var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
        if (!tokensA.length || !tokensB.length) {
          return 0;
        }
        var uniqTokensB = tokensB.filter((token) => !tokensA.includes(token));
        var distanceB = uniqTokensB.join(" ").length / tokensB.join(" ").length;
        return 1 - distanceB;
      },
      /**
       * Checks whether an element node contains a valid byline
       *
       * @param node {Element}
       * @param matchString {string}
       * @return boolean
       */
      _isValidByline(node, matchString) {
        var rel = node.getAttribute("rel");
        var itemprop = node.getAttribute("itemprop");
        var bylineLength = node.textContent.trim().length;
        return (rel === "author" || itemprop && itemprop.includes("author") || this.REGEXPS.byline.test(matchString)) && !!bylineLength && bylineLength < 100;
      },
      _getNodeAncestors(node, maxDepth) {
        maxDepth = maxDepth || 0;
        var i = 0, ancestors = [];
        while (node.parentNode) {
          ancestors.push(node.parentNode);
          if (maxDepth && ++i === maxDepth) {
            break;
          }
          node = node.parentNode;
        }
        return ancestors;
      },
      /***
       * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is
       *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.
       *
       * @param page a document to run upon. Needs to be a full document, complete with body.
       * @return Element
       **/
      /* eslint-disable-next-line complexity */
      _grabArticle(page) {
        this.log("**** grabArticle ****");
        var doc = this._doc;
        var isPaging = page !== null;
        page = page ? page : this._doc.body;
        if (!page) {
          this.log("No body found in document. Abort.");
          return null;
        }
        var pageCacheHtml = page.innerHTML;
        while (true) {
          this.log("Starting grabArticle loop");
          var stripUnlikelyCandidates = this._flagIsActive(
            this.FLAG_STRIP_UNLIKELYS
          );
          var elementsToScore = [];
          var node = this._doc.documentElement;
          let shouldRemoveTitleHeader = true;
          while (node) {
            if (node.tagName === "HTML") {
              this._articleLang = node.getAttribute("lang");
            }
            var matchString = node.className + " " + node.id;
            if (!this._isProbablyVisible(node)) {
              this.log("Removing hidden node - " + matchString);
              node = this._removeAndGetNext(node);
              continue;
            }
            if (node.getAttribute("aria-modal") == "true" && node.getAttribute("role") == "dialog") {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (!this._articleByline && !this._metadata.byline && this._isValidByline(node, matchString)) {
              var endOfSearchMarkerNode = this._getNextNode(node, true);
              var next = this._getNextNode(node);
              var itemPropNameNode = null;
              while (next && next != endOfSearchMarkerNode) {
                var itemprop = next.getAttribute("itemprop");
                if (itemprop && itemprop.includes("name")) {
                  itemPropNameNode = next;
                  break;
                } else {
                  next = this._getNextNode(next);
                }
              }
              this._articleByline = (itemPropNameNode != null ? itemPropNameNode : node).textContent.trim();
              node = this._removeAndGetNext(node);
              continue;
            }
            if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {
              this.log(
                "Removing header: ",
                node.textContent.trim(),
                this._articleTitle.trim()
              );
              shouldRemoveTitleHeader = false;
              node = this._removeAndGetNext(node);
              continue;
            }
            if (stripUnlikelyCandidates) {
              if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, "table") && !this._hasAncestorTag(node, "code") && node.tagName !== "BODY" && node.tagName !== "A") {
                this.log("Removing unlikely candidate - " + matchString);
                node = this._removeAndGetNext(node);
                continue;
              }
              if (this.UNLIKELY_ROLES.includes(node.getAttribute("role"))) {
                this.log(
                  "Removing content with role " + node.getAttribute("role") + " - " + matchString
                );
                node = this._removeAndGetNext(node);
                continue;
              }
            }
            if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" || node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" || node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") && this._isElementWithoutContent(node)) {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (this.DEFAULT_TAGS_TO_SCORE.includes(node.tagName)) {
              elementsToScore.push(node);
            }
            if (node.tagName === "DIV") {
              var p = null;
              var childNode = node.firstChild;
              while (childNode) {
                var nextSibling = childNode.nextSibling;
                if (this._isPhrasingContent(childNode)) {
                  if (p !== null) {
                    p.appendChild(childNode);
                  } else if (!this._isWhitespace(childNode)) {
                    p = doc.createElement("p");
                    node.replaceChild(p, childNode);
                    p.appendChild(childNode);
                  }
                } else if (p !== null) {
                  while (p.lastChild && this._isWhitespace(p.lastChild)) {
                    p.lastChild.remove();
                  }
                  p = null;
                }
                childNode = nextSibling;
              }
              if (this._hasSingleTagInsideElement(node, "P") && this._getLinkDensity(node) < 0.25) {
                var newNode = node.children[0];
                node.parentNode.replaceChild(newNode, node);
                node = newNode;
                elementsToScore.push(node);
              } else if (!this._hasChildBlockElement(node)) {
                node = this._setNodeTag(node, "P");
                elementsToScore.push(node);
              }
            }
            node = this._getNextNode(node);
          }
          var candidates = [];
          this._forEachNode(elementsToScore, function(elementToScore) {
            if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === "undefined") {
              return;
            }
            var innerText = this._getInnerText(elementToScore);
            if (innerText.length < 25) {
              return;
            }
            var ancestors2 = this._getNodeAncestors(elementToScore, 5);
            if (ancestors2.length === 0) {
              return;
            }
            var contentScore = 0;
            contentScore += 1;
            contentScore += innerText.split(this.REGEXPS.commas).length;
            contentScore += Math.min(Math.floor(innerText.length / 100), 3);
            this._forEachNode(ancestors2, function(ancestor, level) {
              if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === "undefined") {
                return;
              }
              if (typeof ancestor.readability === "undefined") {
                this._initializeNode(ancestor);
                candidates.push(ancestor);
              }
              if (level === 0) {
                var scoreDivider = 1;
              } else if (level === 1) {
                scoreDivider = 2;
              } else {
                scoreDivider = level * 3;
              }
              ancestor.readability.contentScore += contentScore / scoreDivider;
            });
          });
          var topCandidates = [];
          for (var c = 0, cl = candidates.length; c < cl; c += 1) {
            var candidate = candidates[c];
            var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));
            candidate.readability.contentScore = candidateScore;
            this.log("Candidate:", candidate, "with score " + candidateScore);
            for (var t2 = 0; t2 < this._nbTopCandidates; t2++) {
              var aTopCandidate = topCandidates[t2];
              if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
                topCandidates.splice(t2, 0, candidate);
                if (topCandidates.length > this._nbTopCandidates) {
                  topCandidates.pop();
                }
                break;
              }
            }
          }
          var topCandidate = topCandidates[0] || null;
          var neededToCreateTopCandidate = false;
          var parentOfTopCandidate;
          if (topCandidate === null || topCandidate.tagName === "BODY") {
            topCandidate = doc.createElement("DIV");
            neededToCreateTopCandidate = true;
            while (page.firstChild) {
              this.log("Moving child out:", page.firstChild);
              topCandidate.appendChild(page.firstChild);
            }
            page.appendChild(topCandidate);
            this._initializeNode(topCandidate);
          } else if (topCandidate) {
            var alternativeCandidateAncestors = [];
            for (var i = 1; i < topCandidates.length; i++) {
              if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
                alternativeCandidateAncestors.push(
                  this._getNodeAncestors(topCandidates[i])
                );
              }
            }
            var MINIMUM_TOPCANDIDATES = 3;
            if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
              parentOfTopCandidate = topCandidate.parentNode;
              while (parentOfTopCandidate.tagName !== "BODY") {
                var listsContainingThisAncestor = 0;
                for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
                  listsContainingThisAncestor += Number(
                    alternativeCandidateAncestors[ancestorIndex].includes(
                      parentOfTopCandidate
                    )
                  );
                }
                if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
                  topCandidate = parentOfTopCandidate;
                  break;
                }
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
              }
            }
            if (!topCandidate.readability) {
              this._initializeNode(topCandidate);
            }
            parentOfTopCandidate = topCandidate.parentNode;
            var lastScore = topCandidate.readability.contentScore;
            var scoreThreshold = lastScore / 3;
            while (parentOfTopCandidate.tagName !== "BODY") {
              if (!parentOfTopCandidate.readability) {
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
                continue;
              }
              var parentScore = parentOfTopCandidate.readability.contentScore;
              if (parentScore < scoreThreshold) {
                break;
              }
              if (parentScore > lastScore) {
                topCandidate = parentOfTopCandidate;
                break;
              }
              lastScore = parentOfTopCandidate.readability.contentScore;
              parentOfTopCandidate = parentOfTopCandidate.parentNode;
            }
            parentOfTopCandidate = topCandidate.parentNode;
            while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
              topCandidate = parentOfTopCandidate;
              parentOfTopCandidate = topCandidate.parentNode;
            }
            if (!topCandidate.readability) {
              this._initializeNode(topCandidate);
            }
          }
          var articleContent = doc.createElement("DIV");
          if (isPaging) {
            articleContent.id = "readability-content";
          }
          var siblingScoreThreshold = Math.max(
            10,
            topCandidate.readability.contentScore * 0.2
          );
          parentOfTopCandidate = topCandidate.parentNode;
          var siblings = parentOfTopCandidate.children;
          for (var s = 0, sl = siblings.length; s < sl; s++) {
            var sibling = siblings[s];
            var append = false;
            this.log(
              "Looking at sibling node:",
              sibling,
              sibling.readability ? "with score " + sibling.readability.contentScore : ""
            );
            this.log(
              "Sibling has score",
              sibling.readability ? sibling.readability.contentScore : "Unknown"
            );
            if (sibling === topCandidate) {
              append = true;
            } else {
              var contentBonus = 0;
              if (sibling.className === topCandidate.className && topCandidate.className !== "") {
                contentBonus += topCandidate.readability.contentScore * 0.2;
              }
              if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {
                append = true;
              } else if (sibling.nodeName === "P") {
                var linkDensity = this._getLinkDensity(sibling);
                var nodeContent = this._getInnerText(sibling);
                var nodeLength = nodeContent.length;
                if (nodeLength > 80 && linkDensity < 0.25) {
                  append = true;
                } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\.( |$)/) !== -1) {
                  append = true;
                }
              }
            }
            if (append) {
              this.log("Appending node:", sibling);
              if (!this.ALTER_TO_DIV_EXCEPTIONS.includes(sibling.nodeName)) {
                this.log("Altering sibling:", sibling, "to div.");
                sibling = this._setNodeTag(sibling, "DIV");
              }
              articleContent.appendChild(sibling);
              siblings = parentOfTopCandidate.children;
              s -= 1;
              sl -= 1;
            }
          }
          if (this._debug) {
            this.log("Article content pre-prep: " + articleContent.innerHTML);
          }
          this._prepArticle(articleContent);
          if (this._debug) {
            this.log("Article content post-prep: " + articleContent.innerHTML);
          }
          if (neededToCreateTopCandidate) {
            topCandidate.id = "readability-page-1";
            topCandidate.className = "page";
          } else {
            var div = doc.createElement("DIV");
            div.id = "readability-page-1";
            div.className = "page";
            while (articleContent.firstChild) {
              div.appendChild(articleContent.firstChild);
            }
            articleContent.appendChild(div);
          }
          if (this._debug) {
            this.log("Article content after paging: " + articleContent.innerHTML);
          }
          var parseSuccessful = true;
          var textLength = this._getInnerText(articleContent, true).length;
          if (textLength < this._charThreshold) {
            parseSuccessful = false;
            page.innerHTML = pageCacheHtml;
            this._attempts.push({
              articleContent,
              textLength
            });
            if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
              this._removeFlag(this.FLAG_STRIP_UNLIKELYS);
            } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
              this._removeFlag(this.FLAG_WEIGHT_CLASSES);
            } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
              this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);
            } else {
              this._attempts.sort(function(a, b) {
                return b.textLength - a.textLength;
              });
              if (!this._attempts[0].textLength) {
                return null;
              }
              articleContent = this._attempts[0].articleContent;
              parseSuccessful = true;
            }
          }
          if (parseSuccessful) {
            var ancestors = [parentOfTopCandidate, topCandidate].concat(
              this._getNodeAncestors(parentOfTopCandidate)
            );
            this._someNode(ancestors, function(ancestor) {
              if (!ancestor.tagName) {
                return false;
              }
              var articleDir = ancestor.getAttribute("dir");
              if (articleDir) {
                this._articleDir = articleDir;
                return true;
              }
              return false;
            });
            return articleContent;
          }
        }
      },
      /**
       * Converts some of the common HTML entities in string to their corresponding characters.
       *
       * @param str {string} - a string to unescape.
       * @return string without HTML entity.
       */
      _unescapeHtmlEntities(str) {
        if (!str) {
          return str;
        }
        var htmlEscapeMap = this.HTML_ESCAPE_MAP;
        return str.replace(/&(quot|amp|apos|lt|gt);/g, function(_, tag) {
          return htmlEscapeMap[tag];
        }).replace(/&#(?:x([0-9a-f]+)|([0-9]+));/gi, function(_, hex, numStr) {
          var num = parseInt(hex || numStr, hex ? 16 : 10);
          if (num == 0 || num > 1114111 || num >= 55296 && num <= 57343) {
            num = 65533;
          }
          return String.fromCodePoint(num);
        });
      },
      /**
       * Try to extract metadata from JSON-LD object.
       * For now, only Schema.org objects of type Article or its subtypes are supported.
       * @return Object with any metadata that could be extracted (possibly none)
       */
      _getJSONLD(doc) {
        var scripts = this._getAllNodesWithTag(doc, ["script"]);
        var metadata;
        this._forEachNode(scripts, function(jsonLdElement) {
          if (!metadata && jsonLdElement.getAttribute("type") === "application/ld+json") {
            try {
              var content = jsonLdElement.textContent.replace(
                /^\s*<!\[CDATA\[|\]\]>\s*$/g,
                ""
              );
              var parsed = JSON.parse(content);
              if (Array.isArray(parsed)) {
                parsed = parsed.find((it) => {
                  return it["@type"] && it["@type"].match(this.REGEXPS.jsonLdArticleTypes);
                });
                if (!parsed) {
                  return;
                }
              }
              var schemaDotOrgRegex = /^https?\:\/\/schema\.org\/?$/;
              var matches = typeof parsed["@context"] === "string" && parsed["@context"].match(schemaDotOrgRegex) || typeof parsed["@context"] === "object" && typeof parsed["@context"]["@vocab"] == "string" && parsed["@context"]["@vocab"].match(schemaDotOrgRegex);
              if (!matches) {
                return;
              }
              if (!parsed["@type"] && Array.isArray(parsed["@graph"])) {
                parsed = parsed["@graph"].find((it) => {
                  return (it["@type"] || "").match(this.REGEXPS.jsonLdArticleTypes);
                });
              }
              if (!parsed || !parsed["@type"] || !parsed["@type"].match(this.REGEXPS.jsonLdArticleTypes)) {
                return;
              }
              metadata = {};
              if (typeof parsed.name === "string" && typeof parsed.headline === "string" && parsed.name !== parsed.headline) {
                var title = this._getArticleTitle();
                var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;
                var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;
                if (headlineMatches && !nameMatches) {
                  metadata.title = parsed.headline;
                } else {
                  metadata.title = parsed.name;
                }
              } else if (typeof parsed.name === "string") {
                metadata.title = parsed.name.trim();
              } else if (typeof parsed.headline === "string") {
                metadata.title = parsed.headline.trim();
              }
              if (parsed.author) {
                if (typeof parsed.author.name === "string") {
                  metadata.byline = parsed.author.name.trim();
                } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === "string") {
                  metadata.byline = parsed.author.filter(function(author) {
                    return author && typeof author.name === "string";
                  }).map(function(author) {
                    return author.name.trim();
                  }).join(", ");
                }
              }
              if (typeof parsed.description === "string") {
                metadata.excerpt = parsed.description.trim();
              }
              if (parsed.publisher && typeof parsed.publisher.name === "string") {
                metadata.siteName = parsed.publisher.name.trim();
              }
              if (typeof parsed.datePublished === "string") {
                metadata.datePublished = parsed.datePublished.trim();
              }
            } catch (err) {
              this.log(err.message);
            }
          }
        });
        return metadata ? metadata : {};
      },
      /**
       * Attempts to get excerpt and byline metadata for the article.
       *
       * @param {Object} jsonld — object containing any metadata that
       * could be extracted from JSON-LD object.
       *
       * @return Object with optional "excerpt" and "byline" properties
       */
      _getArticleMetadata(jsonld) {
        var metadata = {};
        var values = {};
        var metaElements = this._doc.getElementsByTagName("meta");
        var propertyPattern = /\s*(article|dc|dcterm|og|twitter)\s*:\s*(author|creator|description|published_time|title|site_name)\s*/gi;
        var namePattern = /^\s*(?:(dc|dcterm|og|twitter|parsely|weibo:(article|webpage))\s*[-\.:]\s*)?(author|creator|pub-date|description|title|site_name)\s*$/i;
        this._forEachNode(metaElements, function(element) {
          var elementName = element.getAttribute("name");
          var elementProperty = element.getAttribute("property");
          var content = element.getAttribute("content");
          if (!content) {
            return;
          }
          var matches = null;
          var name = null;
          if (elementProperty) {
            matches = elementProperty.match(propertyPattern);
            if (matches) {
              name = matches[0].toLowerCase().replace(/\s/g, "");
              values[name] = content.trim();
            }
          }
          if (!matches && elementName && namePattern.test(elementName)) {
            name = elementName;
            if (content) {
              name = name.toLowerCase().replace(/\s/g, "").replace(/\./g, ":");
              values[name] = content.trim();
            }
          }
        });
        metadata.title = jsonld.title || values["dc:title"] || values["dcterm:title"] || values["og:title"] || values["weibo:article:title"] || values["weibo:webpage:title"] || values.title || values["twitter:title"] || values["parsely-title"];
        if (!metadata.title) {
          metadata.title = this._getArticleTitle();
        }
        const articleAuthor = typeof values["article:author"] === "string" && !this._isUrl(values["article:author"]) ? values["article:author"] : void 0;
        metadata.byline = jsonld.byline || values["dc:creator"] || values["dcterm:creator"] || values.author || values["parsely-author"] || articleAuthor;
        metadata.excerpt = jsonld.excerpt || values["dc:description"] || values["dcterm:description"] || values["og:description"] || values["weibo:article:description"] || values["weibo:webpage:description"] || values.description || values["twitter:description"];
        metadata.siteName = jsonld.siteName || values["og:site_name"];
        metadata.publishedTime = jsonld.datePublished || values["article:published_time"] || values["parsely-pub-date"] || null;
        metadata.title = this._unescapeHtmlEntities(metadata.title);
        metadata.byline = this._unescapeHtmlEntities(metadata.byline);
        metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);
        metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);
        metadata.publishedTime = this._unescapeHtmlEntities(metadata.publishedTime);
        return metadata;
      },
      /**
       * Check if node is image, or if node contains exactly only one image
       * whether as a direct child or as its descendants.
       *
       * @param Element
       **/
      _isSingleImage(node) {
        while (node) {
          if (node.tagName === "IMG") {
            return true;
          }
          if (node.children.length !== 1 || node.textContent.trim() !== "") {
            return false;
          }
          node = node.children[0];
        }
        return false;
      },
      /**
       * Find all <noscript> that are located after <img> nodes, and which contain only one
       * <img> element. Replace the first image with the image from inside the <noscript> tag,
       * and remove the <noscript> tag. This improves the quality of the images we use on
       * some sites (e.g. Medium).
       *
       * @param Element
       **/
      _unwrapNoscriptImages(doc) {
        var imgs = Array.from(doc.getElementsByTagName("img"));
        this._forEachNode(imgs, function(img) {
          for (var i = 0; i < img.attributes.length; i++) {
            var attr = img.attributes[i];
            switch (attr.name) {
              case "src":
              case "srcset":
              case "data-src":
              case "data-srcset":
                return;
            }
            if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
              return;
            }
          }
          img.remove();
        });
        var noscripts = Array.from(doc.getElementsByTagName("noscript"));
        this._forEachNode(noscripts, function(noscript) {
          if (!this._isSingleImage(noscript)) {
            return;
          }
          var tmp = doc.createElement("div");
          tmp.innerHTML = noscript.innerHTML;
          var prevElement = noscript.previousElementSibling;
          if (prevElement && this._isSingleImage(prevElement)) {
            var prevImg = prevElement;
            if (prevImg.tagName !== "IMG") {
              prevImg = prevElement.getElementsByTagName("img")[0];
            }
            var newImg = tmp.getElementsByTagName("img")[0];
            for (var i = 0; i < prevImg.attributes.length; i++) {
              var attr = prevImg.attributes[i];
              if (attr.value === "") {
                continue;
              }
              if (attr.name === "src" || attr.name === "srcset" || /\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
                if (newImg.getAttribute(attr.name) === attr.value) {
                  continue;
                }
                var attrName = attr.name;
                if (newImg.hasAttribute(attrName)) {
                  attrName = "data-old-" + attrName;
                }
                newImg.setAttribute(attrName, attr.value);
              }
            }
            noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);
          }
        });
      },
      /**
       * Removes script tags from the document.
       *
       * @param Element
       **/
      _removeScripts(doc) {
        this._removeNodes(this._getAllNodesWithTag(doc, ["script", "noscript"]));
      },
      /**
       * Check if this node has only whitespace and a single element with given tag
       * Returns false if the DIV node contains non-empty text nodes
       * or if it contains no element with given tag or more than 1 element.
       *
       * @param Element
       * @param string tag of child element
       **/
      _hasSingleTagInsideElement(element, tag) {
        if (element.children.length != 1 || element.children[0].tagName !== tag) {
          return false;
        }
        return !this._someNode(element.childNodes, function(node) {
          return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);
        });
      },
      _isElementWithoutContent(node) {
        return node.nodeType === this.ELEMENT_NODE && !node.textContent.trim().length && (!node.children.length || node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
      },
      /**
       * Determine whether element has any children block level elements.
       *
       * @param Element
       */
      _hasChildBlockElement(element) {
        return this._someNode(element.childNodes, function(node) {
          return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);
        });
      },
      /***
       * Determine if a node qualifies as phrasing content.
       * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
       **/
      _isPhrasingContent(node) {
        return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.includes(node.tagName) || (node.tagName === "A" || node.tagName === "DEL" || node.tagName === "INS") && this._everyNode(node.childNodes, this._isPhrasingContent);
      },
      _isWhitespace(node) {
        return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === "BR";
      },
      /**
       * Get the inner text of a node - cross browser compatibly.
       * This also strips out any excess whitespace to be found.
       *
       * @param Element
       * @param Boolean normalizeSpaces (default: true)
       * @return string
       **/
      _getInnerText(e, normalizeSpaces) {
        normalizeSpaces = typeof normalizeSpaces === "undefined" ? true : normalizeSpaces;
        var textContent = e.textContent.trim();
        if (normalizeSpaces) {
          return textContent.replace(this.REGEXPS.normalize, " ");
        }
        return textContent;
      },
      /**
       * Get the number of times a string s appears in the node e.
       *
       * @param Element
       * @param string - what to split on. Default is ","
       * @return number (integer)
       **/
      _getCharCount(e, s) {
        s = s || ",";
        return this._getInnerText(e).split(s).length - 1;
      },
      /**
       * Remove the style attribute on every e and under.
       * TODO: Test if getElementsByTagName(*) is faster.
       *
       * @param Element
       * @return void
       **/
      _cleanStyles(e) {
        if (!e || e.tagName.toLowerCase() === "svg") {
          return;
        }
        for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {
          e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);
        }
        if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.includes(e.tagName)) {
          e.removeAttribute("width");
          e.removeAttribute("height");
        }
        var cur = e.firstElementChild;
        while (cur !== null) {
          this._cleanStyles(cur);
          cur = cur.nextElementSibling;
        }
      },
      /**
       * Get the density of links as a percentage of the content
       * This is the amount of text that is inside a link divided by the total text in the node.
       *
       * @param Element
       * @return number (float)
       **/
      _getLinkDensity(element) {
        var textLength = this._getInnerText(element).length;
        if (textLength === 0) {
          return 0;
        }
        var linkLength = 0;
        this._forEachNode(element.getElementsByTagName("a"), function(linkNode) {
          var href = linkNode.getAttribute("href");
          var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;
          linkLength += this._getInnerText(linkNode).length * coefficient;
        });
        return linkLength / textLength;
      },
      /**
       * Get an elements class/id weight. Uses regular expressions to tell if this
       * element looks good or bad.
       *
       * @param Element
       * @return number (Integer)
       **/
      _getClassWeight(e) {
        if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
          return 0;
        }
        var weight = 0;
        if (typeof e.className === "string" && e.className !== "") {
          if (this.REGEXPS.negative.test(e.className)) {
            weight -= 25;
          }
          if (this.REGEXPS.positive.test(e.className)) {
            weight += 25;
          }
        }
        if (typeof e.id === "string" && e.id !== "") {
          if (this.REGEXPS.negative.test(e.id)) {
            weight -= 25;
          }
          if (this.REGEXPS.positive.test(e.id)) {
            weight += 25;
          }
        }
        return weight;
      },
      /**
       * Clean a node of all elements of type "tag".
       * (Unless it's a youtube/vimeo video. People love movies.)
       *
       * @param Element
       * @param string tag to clean
       * @return void
       **/
      _clean(e, tag) {
        var isEmbed = ["object", "embed", "iframe"].includes(tag);
        this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(element) {
          if (isEmbed) {
            for (var i = 0; i < element.attributes.length; i++) {
              if (this._allowedVideoRegex.test(element.attributes[i].value)) {
                return false;
              }
            }
            if (element.tagName === "object" && this._allowedVideoRegex.test(element.innerHTML)) {
              return false;
            }
          }
          return true;
        });
      },
      /**
       * Check if a given node has one of its ancestor tag name matching the
       * provided one.
       * @param  HTMLElement node
       * @param  String      tagName
       * @param  Number      maxDepth
       * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'
       * @return Boolean
       */
      _hasAncestorTag(node, tagName, maxDepth, filterFn) {
        maxDepth = maxDepth || 3;
        tagName = tagName.toUpperCase();
        var depth = 0;
        while (node.parentNode) {
          if (maxDepth > 0 && depth > maxDepth) {
            return false;
          }
          if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode))) {
            return true;
          }
          node = node.parentNode;
          depth++;
        }
        return false;
      },
      /**
       * Return an object indicating how many rows and columns this table has.
       */
      _getRowAndColumnCount(table) {
        var rows = 0;
        var columns = 0;
        var trs = table.getElementsByTagName("tr");
        for (var i = 0; i < trs.length; i++) {
          var rowspan = trs[i].getAttribute("rowspan") || 0;
          if (rowspan) {
            rowspan = parseInt(rowspan, 10);
          }
          rows += rowspan || 1;
          var columnsInThisRow = 0;
          var cells = trs[i].getElementsByTagName("td");
          for (var j = 0; j < cells.length; j++) {
            var colspan = cells[j].getAttribute("colspan") || 0;
            if (colspan) {
              colspan = parseInt(colspan, 10);
            }
            columnsInThisRow += colspan || 1;
          }
          columns = Math.max(columns, columnsInThisRow);
        }
        return { rows, columns };
      },
      /**
       * Look for 'data' (as opposed to 'layout') tables, for which we use
       * similar checks as
       * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19
       */
      _markDataTables(root) {
        var tables = root.getElementsByTagName("table");
        for (var i = 0; i < tables.length; i++) {
          var table = tables[i];
          var role = table.getAttribute("role");
          if (role == "presentation") {
            table._readabilityDataTable = false;
            continue;
          }
          var datatable = table.getAttribute("datatable");
          if (datatable == "0") {
            table._readabilityDataTable = false;
            continue;
          }
          var summary = table.getAttribute("summary");
          if (summary) {
            table._readabilityDataTable = true;
            continue;
          }
          var caption = table.getElementsByTagName("caption")[0];
          if (caption && caption.childNodes.length) {
            table._readabilityDataTable = true;
            continue;
          }
          var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];
          var descendantExists = function(tag) {
            return !!table.getElementsByTagName(tag)[0];
          };
          if (dataTableDescendants.some(descendantExists)) {
            this.log("Data table because found data-y descendant");
            table._readabilityDataTable = true;
            continue;
          }
          if (table.getElementsByTagName("table")[0]) {
            table._readabilityDataTable = false;
            continue;
          }
          var sizeInfo = this._getRowAndColumnCount(table);
          if (sizeInfo.columns == 1 || sizeInfo.rows == 1) {
            table._readabilityDataTable = false;
            continue;
          }
          if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
            table._readabilityDataTable = true;
            continue;
          }
          table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
        }
      },
      /* convert images and figures that have properties like data-src into images that can be loaded without JS */
      _fixLazyImages(root) {
        this._forEachNode(
          this._getAllNodesWithTag(root, ["img", "picture", "figure"]),
          function(elem) {
            if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {
              var parts = this.REGEXPS.b64DataUrl.exec(elem.src);
              if (parts[1] === "image/svg+xml") {
                return;
              }
              var srcCouldBeRemoved = false;
              for (var i = 0; i < elem.attributes.length; i++) {
                var attr = elem.attributes[i];
                if (attr.name === "src") {
                  continue;
                }
                if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
                  srcCouldBeRemoved = true;
                  break;
                }
              }
              if (srcCouldBeRemoved) {
                var b64starts = parts[0].length;
                var b64length = elem.src.length - b64starts;
                if (b64length < 133) {
                  elem.removeAttribute("src");
                }
              }
            }
            if ((elem.src || elem.srcset && elem.srcset != "null") && !elem.className.toLowerCase().includes("lazy")) {
              return;
            }
            for (var j = 0; j < elem.attributes.length; j++) {
              attr = elem.attributes[j];
              if (attr.name === "src" || attr.name === "srcset" || attr.name === "alt") {
                continue;
              }
              var copyTo = null;
              if (/\.(jpg|jpeg|png|webp)\s+\d/.test(attr.value)) {
                copyTo = "srcset";
              } else if (/^\s*\S+\.(jpg|jpeg|png|webp)\S*\s*$/.test(attr.value)) {
                copyTo = "src";
              }
              if (copyTo) {
                if (elem.tagName === "IMG" || elem.tagName === "PICTURE") {
                  elem.setAttribute(copyTo, attr.value);
                } else if (elem.tagName === "FIGURE" && !this._getAllNodesWithTag(elem, ["img", "picture"]).length) {
                  var img = this._doc.createElement("img");
                  img.setAttribute(copyTo, attr.value);
                  elem.appendChild(img);
                }
              }
            }
          }
        );
      },
      _getTextDensity(e, tags) {
        var textLength = this._getInnerText(e, true).length;
        if (textLength === 0) {
          return 0;
        }
        var childrenLength = 0;
        var children = this._getAllNodesWithTag(e, tags);
        this._forEachNode(
          children,
          (child) => childrenLength += this._getInnerText(child, true).length
        );
        return childrenLength / textLength;
      },
      /**
       * Clean an element of all tags of type "tag" if they look fishy.
       * "Fishy" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.
       *
       * @return void
       **/
      _cleanConditionally(e, tag) {
        if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
          return;
        }
        this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(node) {
          var isDataTable = function(t2) {
            return t2._readabilityDataTable;
          };
          var isList = tag === "ul" || tag === "ol";
          if (!isList) {
            var listLength = 0;
            var listNodes = this._getAllNodesWithTag(node, ["ul", "ol"]);
            this._forEachNode(
              listNodes,
              (list) => listLength += this._getInnerText(list).length
            );
            isList = listLength / this._getInnerText(node).length > 0.9;
          }
          if (tag === "table" && isDataTable(node)) {
            return false;
          }
          if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
            return false;
          }
          if (this._hasAncestorTag(node, "code")) {
            return false;
          }
          if ([...node.getElementsByTagName("table")].some(
            (tbl) => tbl._readabilityDataTable
          )) {
            return false;
          }
          var weight = this._getClassWeight(node);
          this.log("Cleaning Conditionally", node);
          var contentScore = 0;
          if (weight + contentScore < 0) {
            return true;
          }
          if (this._getCharCount(node, ",") < 10) {
            var p = node.getElementsByTagName("p").length;
            var img = node.getElementsByTagName("img").length;
            var li = node.getElementsByTagName("li").length - 100;
            var input = node.getElementsByTagName("input").length;
            var headingDensity = this._getTextDensity(node, [
              "h1",
              "h2",
              "h3",
              "h4",
              "h5",
              "h6"
            ]);
            var embedCount = 0;
            var embeds = this._getAllNodesWithTag(node, [
              "object",
              "embed",
              "iframe"
            ]);
            for (var i = 0; i < embeds.length; i++) {
              for (var j = 0; j < embeds[i].attributes.length; j++) {
                if (this._allowedVideoRegex.test(embeds[i].attributes[j].value)) {
                  return false;
                }
              }
              if (embeds[i].tagName === "object" && this._allowedVideoRegex.test(embeds[i].innerHTML)) {
                return false;
              }
              embedCount++;
            }
            var innerText = this._getInnerText(node);
            if (this.REGEXPS.adWords.test(innerText) || this.REGEXPS.loadingWords.test(innerText)) {
              return true;
            }
            var contentLength = innerText.length;
            var linkDensity = this._getLinkDensity(node);
            var textishTags = ["SPAN", "LI", "TD"].concat(
              Array.from(this.DIV_TO_P_ELEMS)
            );
            var textDensity = this._getTextDensity(node, textishTags);
            var isFigureChild = this._hasAncestorTag(node, "figure");
            const shouldRemoveNode = () => {
              const errs = [];
              if (!isFigureChild && img > 1 && p / img < 0.5) {
                errs.push(`Bad p to img ratio (img=${img}, p=${p})`);
              }
              if (!isList && li > p) {
                errs.push(`Too many li's outside of a list. (li=${li} > p=${p})`);
              }
              if (input > Math.floor(p / 3)) {
                errs.push(`Too many inputs per p. (input=${input}, p=${p})`);
              }
              if (!isList && !isFigureChild && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && linkDensity > 0) {
                errs.push(
                  `Suspiciously short. (headingDensity=${headingDensity}, img=${img}, linkDensity=${linkDensity})`
                );
              }
              if (!isList && weight < 25 && linkDensity > 0.2 + this._linkDensityModifier) {
                errs.push(
                  `Low weight and a little linky. (linkDensity=${linkDensity})`
                );
              }
              if (weight >= 25 && linkDensity > 0.5 + this._linkDensityModifier) {
                errs.push(
                  `High weight and mostly links. (linkDensity=${linkDensity})`
                );
              }
              if (embedCount === 1 && contentLength < 75 || embedCount > 1) {
                errs.push(
                  `Suspicious embed. (embedCount=${embedCount}, contentLength=${contentLength})`
                );
              }
              if (img === 0 && textDensity === 0) {
                errs.push(
                  `No useful content. (img=${img}, textDensity=${textDensity})`
                );
              }
              if (errs.length) {
                this.log("Checks failed", errs);
                return true;
              }
              return false;
            };
            var haveToRemove = shouldRemoveNode();
            if (isList && haveToRemove) {
              for (var x = 0; x < node.children.length; x++) {
                let child = node.children[x];
                if (child.children.length > 1) {
                  return haveToRemove;
                }
              }
              let li_count = node.getElementsByTagName("li").length;
              if (img == li_count) {
                return false;
              }
            }
            return haveToRemove;
          }
          return false;
        });
      },
      /**
       * Clean out elements that match the specified conditions
       *
       * @param Element
       * @param Function determines whether a node should be removed
       * @return void
       **/
      _cleanMatchedNodes(e, filter) {
        var endOfSearchMarkerNode = this._getNextNode(e, true);
        var next = this._getNextNode(e);
        while (next && next != endOfSearchMarkerNode) {
          if (filter.call(this, next, next.className + " " + next.id)) {
            next = this._removeAndGetNext(next);
          } else {
            next = this._getNextNode(next);
          }
        }
      },
      /**
       * Clean out spurious headers from an Element.
       *
       * @param Element
       * @return void
       **/
      _cleanHeaders(e) {
        let headingNodes = this._getAllNodesWithTag(e, ["h1", "h2"]);
        this._removeNodes(headingNodes, function(node) {
          let shouldRemove = this._getClassWeight(node) < 0;
          if (shouldRemove) {
            this.log("Removing header with low class weight:", node);
          }
          return shouldRemove;
        });
      },
      /**
       * Check if this node is an H1 or H2 element whose content is mostly
       * the same as the article title.
       *
       * @param Element  the node to check.
       * @return boolean indicating whether this is a title-like header.
       */
      _headerDuplicatesTitle(node) {
        if (node.tagName != "H1" && node.tagName != "H2") {
          return false;
        }
        var heading = this._getInnerText(node, false);
        this.log("Evaluating similarity of header:", heading, this._articleTitle);
        return this._textSimilarity(this._articleTitle, heading) > 0.75;
      },
      _flagIsActive(flag) {
        return (this._flags & flag) > 0;
      },
      _removeFlag(flag) {
        this._flags = this._flags & ~flag;
      },
      _isProbablyVisible(node) {
        return (!node.style || node.style.display != "none") && (!node.style || node.style.visibility != "hidden") && !node.hasAttribute("hidden") && //check for "fallback-image" so that wikimedia math images are displayed
        (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.includes && node.className.includes("fallback-image"));
      },
      /**
       * Runs readability.
       *
       * Workflow:
       *  1. Prep the document by removing script tags, css, etc.
       *  2. Build readability's DOM tree.
       *  3. Grab the article content from the current dom tree.
       *  4. Replace the current DOM tree with the new one.
       *  5. Read peacefully.
       *
       * @return void
       **/
      parse() {
        if (this._maxElemsToParse > 0) {
          var numTags = this._doc.getElementsByTagName("*").length;
          if (numTags > this._maxElemsToParse) {
            throw new Error(
              "Aborting parsing document; " + numTags + " elements found"
            );
          }
        }
        this._unwrapNoscriptImages(this._doc);
        var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);
        this._removeScripts(this._doc);
        this._prepDocument();
        var metadata = this._getArticleMetadata(jsonLd);
        this._metadata = metadata;
        this._articleTitle = metadata.title;
        var articleContent = this._grabArticle();
        if (!articleContent) {
          return null;
        }
        this.log("Grabbed: " + articleContent.innerHTML);
        this._postProcessContent(articleContent);
        if (!metadata.excerpt) {
          var paragraphs = articleContent.getElementsByTagName("p");
          if (paragraphs.length) {
            metadata.excerpt = paragraphs[0].textContent.trim();
          }
        }
        var textContent = articleContent.textContent;
        return {
          title: this._articleTitle,
          byline: metadata.byline || this._articleByline,
          dir: this._articleDir,
          lang: this._articleLang,
          content: this._serializer(articleContent),
          textContent,
          length: textContent.length,
          excerpt: metadata.excerpt,
          siteName: metadata.siteName || this._articleSiteName,
          publishedTime: metadata.publishedTime
        };
      }
    };
    if (typeof module2 === "object") {
      module2.exports = Readability2;
    }
  }
});

// node_modules/@mozilla/readability/Readability-readerable.js
var require_Readability_readerable = __commonJS({
  "node_modules/@mozilla/readability/Readability-readerable.js"(exports, module2) {
    var REGEXPS = {
      // NOTE: These two regular expressions are duplicated in
      // Readability.js. Please keep both copies in sync.
      unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
      okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i
    };
    function isNodeVisible(node) {
      return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && //check for "fallback-image" so that wikimedia math images are displayed
      (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.includes && node.className.includes("fallback-image"));
    }
    function isProbablyReaderable(doc, options = {}) {
      if (typeof options == "function") {
        options = { visibilityChecker: options };
      }
      var defaultOptions = {
        minScore: 20,
        minContentLength: 140,
        visibilityChecker: isNodeVisible
      };
      options = Object.assign(defaultOptions, options);
      var nodes = doc.querySelectorAll("p, pre, article");
      var brNodes = doc.querySelectorAll("div > br");
      if (brNodes.length) {
        var set = new Set(nodes);
        [].forEach.call(brNodes, function(node) {
          set.add(node.parentNode);
        });
        nodes = Array.from(set);
      }
      var score = 0;
      return [].some.call(nodes, function(node) {
        if (!options.visibilityChecker(node)) {
          return false;
        }
        var matchString = node.className + " " + node.id;
        if (REGEXPS.unlikelyCandidates.test(matchString) && !REGEXPS.okMaybeItsACandidate.test(matchString)) {
          return false;
        }
        if (node.matches("li p")) {
          return false;
        }
        var textContentLength = node.textContent.trim().length;
        if (textContentLength < options.minContentLength) {
          return false;
        }
        score += Math.sqrt(textContentLength - options.minContentLength);
        if (score > options.minScore) {
          return true;
        }
        return false;
      });
    }
    if (typeof module2 === "object") {
      module2.exports = isProbablyReaderable;
    }
  }
});

// node_modules/@mozilla/readability/index.js
var require_readability = __commonJS({
  "node_modules/@mozilla/readability/index.js"(exports, module2) {
    var Readability2 = require_Readability();
    var isProbablyReaderable = require_Readability_readerable();
    module2.exports = {
      Readability: Readability2,
      isProbablyReaderable
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NetClipPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian18 = require("obsidian");

// src/view/ClipperView.ts
var import_obsidian9 = require("obsidian");

// src/utils.ts
function normalizeUrl(url) {
  try {
    const parsedUrl = new URL(url);
    const trackingParams = [
      "utm_source",
      "utm_medium",
      "utm_campaign",
      "utm_term",
      "utm_content",
      "fbclid",
      "gclid"
    ];
    trackingParams.forEach((param) => {
      parsedUrl.searchParams.delete(param);
    });
    return parsedUrl.toString();
  } catch (e) {
    return null;
  }
}
function sanitizePath(path) {
  return path.replace(/[\/\\:*?"<>|]/g, "_").replace(/\s+/g, " ").trim();
}
function getDomain(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.hostname.replace(/^www\./, "");
  } catch (e) {
    return "Unknown Domain";
  }
}

// src/modal/deleteFiles.ts
var import_obsidian = require("obsidian");
var DeleteConfirmationModal = class extends import_obsidian.Modal {
  constructor(app, file, onConfirmDelete) {
    super(app);
    this.file = file;
    this.onConfirmDelete = onConfirmDelete;
  }
  onOpen() {
    this.titleEl.setText("Confirm delete");
    this.contentEl.createEl("p", { text: `Are you sure you want to delete the article "${this.file.basename}"?` });
    const buttonContainer = this.contentEl.createEl("div", { cls: "netclip_button-container" });
    const confirmButton = buttonContainer.createEl("button", {
      cls: "netclip_warning",
      text: "Delete"
    });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    confirmButton.addEventListener("click", async () => {
      await this.onConfirmDelete();
      this.close();
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/contextMenu.ts
var import_obsidian8 = require("obsidian");

// src/view/ModalWebView.ts
var import_obsidian6 = require("obsidian");

// src/webViewComponent.ts
var import_obsidian5 = require("obsidian");

// src/search/searchUrls.ts
var baseSearchUrls = {
  google: "https://www.google.com/search?q=",
  youtube: "https://www.youtube.com/results?search_query=",
  bing: "https://www.bing.com/search?q=",
  perplexity: "https://www.perplexity.ai/search/new?q=",
  duckduckgo: "https://duckduckgo.com/?q=",
  genspark: "https://www.genspark.ai/search?query=",
  kagi: "https://kagi.com/search?q=",
  yahoo: "http://search.yahoo.com/search?p="
};

// src/search/fetchSuggestions.ts
var import_obsidian2 = require("obsidian");
var fetchSuggestions = (query, suggestionContainer, suggestionsBox, selectSuggestion) => {
  while (suggestionsBox.firstChild) {
    suggestionsBox.removeChild(suggestionsBox.firstChild);
  }
  if (!query || query.trim() === "") {
    suggestionContainer.classList.add("netclip_search_hidden");
    return;
  }
  (0, import_obsidian2.requestUrl)({
    url: `https://suggestqueries.google.com/complete/search?client=chrome&q=${encodeURIComponent(query)}`,
    method: "GET",
    headers: {
      "User-Agent": "Mozilla/5.0",
      "Accept": "application/json"
    }
  }).then((response) => {
    if (response.status !== 200) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    try {
      const data = JSON.parse(response.text);
      const suggestions = data[1] || [];
      suggestions.forEach((suggestion) => {
        const suggestionDiv = document.createElement("div");
        suggestionDiv.classList.add("netClip-suggestion-item");
        const textSpan = document.createElement("span");
        textSpan.textContent = suggestion;
        suggestionDiv.appendChild(textSpan);
        suggestionDiv.addEventListener("click", () => selectSuggestion(suggestion));
        suggestionsBox.appendChild(suggestionDiv);
      });
      if (suggestions.length > 0) {
        suggestionContainer.classList.remove("netclip_search_hidden");
      } else {
        suggestionContainer.classList.add("netclip_search_hidden");
      }
    } catch (parseError) {
      console.error("Error parsing suggestions:", parseError);
      suggestionContainer.classList.add("netclip_search_hidden");
    }
  }).catch((error) => {
    console.error("Error fetching suggestions:", error);
    suggestionContainer.classList.add("netclip_search_hidden");
  });
};

// src/search/search.ts
var WebSearch = class {
  constructor(searchInput, suggestionContainer, suggestionsBox, settings = {}) {
    this.currentSuggestionIndex = -1;
    this.isVisible = false;
    this.baseSearchUrls = baseSearchUrls;
    this.searchInput = searchInput;
    this.suggestionContainer = suggestionContainer;
    this.suggestionsBox = suggestionsBox;
    this.settings = {
      searchEngine: "google",
      ...settings
    };
    this.suggestionContainer.classList.add("netclip_search_hidden");
    this.handleInput = this.onInput.bind(this);
    this.handleKeydown = this.onKeydown.bind(this);
    this.handleBlur = this.onBlur.bind(this);
    this.handleWindowClick = this.onWindowClick.bind(this);
    this.setupEventListeners();
  }
  setupEventListeners() {
    this.searchInput.addEventListener("input", this.handleInput);
    this.searchInput.addEventListener("keydown", this.handleKeydown);
    this.searchInput.addEventListener("blur", this.handleBlur);
    window.addEventListener("click", this.handleWindowClick, true);
    const frameContainer = document.querySelector(".netClip_frame-container");
    if (frameContainer) {
      frameContainer.addEventListener("click", () => {
        this.hideSuggestions();
      }, true);
    }
  }
  onInput() {
    const query = this.searchInput.value.trim();
    if (query === "") {
      this.hideSuggestions();
    } else {
      this.showSuggestions();
      fetchSuggestions(
        query,
        this.suggestionContainer,
        this.suggestionsBox,
        this.selectSuggestion.bind(this)
      );
    }
  }
  onKeydown(event) {
    const suggestions = this.suggestionsBox.children;
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        this.navigateSuggestions("down", suggestions);
        break;
      case "ArrowUp":
        event.preventDefault();
        this.navigateSuggestions("up", suggestions);
        break;
      case "Enter":
        event.preventDefault();
        this.handleEnterKey(suggestions);
        break;
      case "Escape":
        this.hideSuggestions();
        break;
    }
  }
  onBlur(event) {
    setTimeout(() => {
      if (!this.suggestionContainer.contains(document.activeElement)) {
        this.hideSuggestions();
      }
    }, 200);
  }
  onWindowClick(event) {
    const target = event.target;
    if (!this.searchInput.contains(target) && !this.suggestionContainer.contains(target)) {
      this.hideSuggestions();
    }
  }
  isValidUrl(str) {
    try {
      new URL(str);
      return true;
    } catch (e) {
      return false;
    }
  }
  constructSearchUrl(query) {
    const selectedEngine = this.settings.searchEngine || "google";
    const baseSearchUrl = this.baseSearchUrls[selectedEngine];
    const encodedQuery = encodeURIComponent(query.trim());
    return `${baseSearchUrl}${encodedQuery}`;
  }
  navigateToQuery(query) {
    const searchUrl = this.isValidUrl(query) ? query : this.constructSearchUrl(query);
    const event = new CustomEvent("search-query", {
      detail: { url: searchUrl, query }
    });
    this.searchInput.dispatchEvent(event);
    return searchUrl;
  }
  selectSuggestion(suggestion) {
    this.searchInput.value = suggestion;
    this.navigateToQuery(suggestion);
    this.hideSuggestions();
  }
  navigateSuggestions(direction, suggestions) {
    if (suggestions.length === 0) return;
    if (this.currentSuggestionIndex !== -1) {
      suggestions[this.currentSuggestionIndex].classList.remove("selected");
    }
    if (direction === "down") {
      this.currentSuggestionIndex = this.currentSuggestionIndex < suggestions.length - 1 ? this.currentSuggestionIndex + 1 : -1;
    } else {
      this.currentSuggestionIndex = this.currentSuggestionIndex > -1 ? this.currentSuggestionIndex - 1 : suggestions.length - 1;
    }
    if (this.currentSuggestionIndex === -1) {
      this.searchInput.value = this.searchInput.getAttribute("data-original-value") || "";
    } else {
      const selectedSuggestion = suggestions[this.currentSuggestionIndex];
      selectedSuggestion.classList.add("selected");
      this.searchInput.value = selectedSuggestion.textContent || "";
    }
  }
  handleEnterKey(suggestions) {
    if (this.currentSuggestionIndex !== -1 && suggestions[this.currentSuggestionIndex]) {
      suggestions[this.currentSuggestionIndex].click();
    } else {
      const query = this.searchInput.value;
      if (query) {
        this.navigateToQuery(query);
      }
    }
    this.hideSuggestions();
  }
  showSuggestions() {
    this.isVisible = true;
    this.suggestionContainer.classList.remove("netclip_search_hidden");
  }
  hideSuggestions() {
    this.suggestionContainer.classList.add("netclip_search_hidden");
    while (this.suggestionsBox.firstChild) {
      this.suggestionsBox.removeChild(this.suggestionsBox.firstChild);
    }
    this.currentSuggestionIndex = -1;
  }
  unload() {
    this.searchInput.removeEventListener("input", this.handleInput);
    this.searchInput.removeEventListener("keydown", this.handleKeydown);
    this.searchInput.removeEventListener("blur", this.handleBlur);
    window.removeEventListener("click", this.handleWindowClick);
    this.hideSuggestions();
    if (this.suggestionContainer.parentNode) {
      this.suggestionContainer.remove();
    }
    if (this.suggestionsBox.parentNode) {
      this.suggestionsBox.remove();
    }
  }
};

// src/modal/clipModal.ts
var import_obsidian4 = require("obsidian");

// src/modal/aiProcessingModal.ts
var import_obsidian3 = require("obsidian");
var AIProcessingModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, url, category, selectedPrompts, selectedVariables, keepOriginalContent = true) {
    super(app);
    this.plugin = plugin;
    this.url = url;
    this.category = category;
    this.selectedPrompts = selectedPrompts;
    this.selectedVariables = selectedVariables;
    this.keepOriginalContent = keepOriginalContent;
    this.aiStepElements = [];
    this.currentStep = 0;
    this.aiSteps = [
      "Extracting content from webpage...",
      "Analyzing content structure...",
      "Processing with AI model..."
    ];
    this.promptProgressElements = /* @__PURE__ */ new Map();
    this.selectedPrompts.forEach((prompt) => {
      this.aiSteps.push(`Applying prompt: ${prompt.name}...`);
    });
    this.aiSteps.push("Formatting final document...");
  }
  async onOpen() {
    this.modalEl.addClass("netclip_ai_processing_modal");
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("netclip_ai_processing_content");
    contentEl.createEl("h2", { text: "AI Processing" });
    const infoMessage = contentEl.createDiv({ cls: "netclip_info_message" });
    const infoIcon = infoMessage.createDiv({ cls: "netclip_info_icon" });
    (0, import_obsidian3.setIcon)(infoIcon, "info");
    const infoText = infoMessage.createDiv({ cls: "netclip_info_text" });
    infoText.setText("You can close this modal. You'll be notified when it's done.");
    const aiProcessingContainer = contentEl.createDiv({ cls: "netclip_ai_processing_container" });
    const aiAnimationContainer = aiProcessingContainer.createDiv({ cls: "netclip_ai_animation" });
    this.aiStatusText = aiProcessingContainer.createDiv({ cls: "netclip_ai_status" });
    this.aiStatusText.setText("Initializing AI processing...");
    const typingContainer = aiAnimationContainer.createDiv({ cls: "netclip_typing_animation" });
    for (let i = 0; i < 3; i++) {
      typingContainer.createDiv({ cls: "netclip_typing_dot" });
    }
    const aiStepsContainer = aiProcessingContainer.createDiv({ cls: "netclip_ai_steps" });
    this.aiStepElements = [];
    this.aiSteps.forEach((step) => {
      const stepEl = aiStepsContainer.createDiv({ cls: "netclip_ai_step" });
      stepEl.setText(step);
      this.aiStepElements.push(stepEl);
    });
    this.promptProgressContainer = aiProcessingContainer.createDiv({ cls: "netclip_prompt_progress" });
    this.promptProgressContainer.style.display = "none";
    document.addEventListener("netclip-ai-progress", this.handleAIProgress.bind(this));
    this.processWithAnimation();
  }
  handleAIProgress(event) {
    const { total, current, promptName } = event.detail;
    this.aiStatusText.setText(`Processing prompt ${current}/${total}: ${promptName}`);
    this.promptProgressContainer.style.display = "block";
    if (!this.promptProgressElements.has(promptName)) {
      const promptEl = this.promptProgressContainer.createDiv({ cls: "netclip_prompt_item" });
      const promptName_el = promptEl.createDiv({ cls: "netclip_prompt_name" });
      promptName_el.setText(promptName);
      const promptStatus = promptEl.createDiv({ cls: "netclip_prompt_status" });
      promptStatus.setText("Processing...");
      promptStatus.addClass("processing");
      this.promptProgressElements.set(promptName, promptStatus);
    }
    this.selectedPrompts.forEach((prompt, index) => {
      if (index < current - 1) {
        const status = this.promptProgressElements.get(prompt.name);
        if (status) {
          status.setText("Completed");
          status.removeClass("processing");
          status.addClass("completed");
        }
      }
    });
  }
  updateStep() {
    this.aiStepElements.forEach((el, index) => {
      if (index < this.currentStep) {
        el.addClass("completed");
      } else if (index === this.currentStep) {
        el.addClass("active");
      } else {
        el.removeClass("active", "completed");
      }
    });
  }
  async processWithAnimation() {
    try {
      this.updateStep();
      const stepDelay = 1e3;
      await new Promise((resolve) => setTimeout(resolve, stepDelay));
      this.currentStep++;
      this.updateStep();
      await new Promise((resolve) => setTimeout(resolve, stepDelay));
      this.currentStep++;
      this.updateStep();
      await new Promise((resolve) => setTimeout(resolve, stepDelay));
      this.currentStep++;
      this.updateStep();
      await this.plugin.clipWebpage(
        this.url,
        this.category,
        this.selectedPrompts,
        this.selectedVariables,
        this.keepOriginalContent
      );
      this.currentStep = this.aiSteps.length - 1;
      this.updateStep();
      await new Promise((resolve) => setTimeout(resolve, stepDelay));
      document.removeEventListener("netclip-ai-progress", this.handleAIProgress.bind(this));
      new import_obsidian3.Notice("AI processing completed successfully!", 5e3);
      this.close();
    } catch (error) {
      this.aiStatusText.setText(`Error: ${error.message}`);
      this.aiStatusText.addClass("error");
      const errorCloseBtn = this.contentEl.createEl("button", {
        text: "Close",
        cls: "netclip_error_close"
      });
      errorCloseBtn.addEventListener("click", () => {
        document.removeEventListener("netclip-ai-progress", this.handleAIProgress.bind(this));
        this.close();
      });
      new import_obsidian3.Notice(`AI processing failed: ${error.message}`, 5e3);
    }
  }
  onClose() {
    document.removeEventListener("netclip-ai-progress", this.handleAIProgress.bind(this));
    this.contentEl.empty();
  }
};

// src/modal/clipModal.ts
var ClipModal = class extends import_obsidian4.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.selectedPrompts = [];
    this.selectedVariables = {};
    this.keepOriginalContent = this.plugin.settings.keepOriginalContent;
  }
  async tryGetClipboardUrl() {
    try {
      const text = await navigator.clipboard.readText();
      if (text.startsWith("http")) {
        return text;
      }
    } catch (error) {
      console.error("Failed to read clipboard:", error);
    }
    return null;
  }
  renderVariableSelectors(promptDiv, prompt) {
    if (!prompt.variables || Object.keys(prompt.variables).length === 0) return;
    const varContainer = promptDiv.createDiv({
      cls: `prompt-variables-${prompt.name.replace(/\s+/g, "-")}`
    });
    Object.entries(prompt.variables).forEach(([key, options]) => {
      new import_obsidian4.Setting(varContainer).setName(key).addDropdown((dropdown) => {
        options.forEach((option) => dropdown.addOption(option, option));
        dropdown.onChange((value) => {
          if (!this.selectedVariables[prompt.name]) {
            this.selectedVariables[prompt.name] = {};
          }
          this.selectedVariables[prompt.name][key] = value;
        });
      });
    });
  }
  async onOpen() {
    this.modalEl.addClass("netclip_clip_modal");
    const { contentEl } = this;
    contentEl.addClass("netclip_clip_modal_content");
    contentEl.createEl("h2", { text: "Clip webpage" });
    const clipContainer = contentEl.createDiv({ cls: "netclip_clip_container" });
    const urlContainer = clipContainer.createDiv({ cls: "netclip_clip_url_container" });
    urlContainer.createEl("label", { text: "Url:" });
    const urlInput = urlContainer.createEl("input", {
      type: "text",
      cls: "netclip_clip_input",
      placeholder: "Enter URL to clip..."
    });
    const clipboardUrl = await this.tryGetClipboardUrl();
    if (clipboardUrl) {
      urlInput.value = clipboardUrl;
    }
    const categoryContainer = clipContainer.createDiv({ cls: "netclip_clip_category_container" });
    categoryContainer.createEl("label", { text: "Save to:" });
    const categorySelect = categoryContainer.createEl("select");
    categorySelect.createEl("option", {
      value: "",
      text: "All"
    });
    this.plugin.settings.categories.forEach((category) => {
      categorySelect.createEl("option", {
        value: category,
        text: category
      });
    });
    if (this.plugin.settings.enableAI && this.plugin.settings.geminiApiKey) {
      const aipromptContainer = contentEl.createDiv({ cls: "ai_prompt_container" });
      aipromptContainer.createEl("h3", { text: "AI Processing" });
      const promptContainer = aipromptContainer.createEl("div", { cls: "netclip_prompt_container" });
      new import_obsidian4.Setting(aipromptContainer).setName("Keep Original Content").setDesc("Keep the original content when applying AI prompts").addToggle((toggle) => toggle.setValue(this.keepOriginalContent).onChange((value) => {
        this.keepOriginalContent = value;
        this.plugin.settings.keepOriginalContent = value;
        this.plugin.saveSettings();
      }));
      const enabledPrompts = this.plugin.settings.prompts.filter((prompt) => prompt.enabled);
      enabledPrompts.forEach((prompt) => {
        const promptDiv = promptContainer.createDiv({ cls: "prompt-section" });
        new import_obsidian4.Setting(promptDiv).setName(prompt.name).addToggle((toggle) => toggle.setValue(false).onChange((value) => {
          if (value) {
            if (!this.selectedPrompts.includes(prompt)) {
              this.selectedPrompts.push(prompt);
              this.selectedVariables[prompt.name] = {};
              this.renderVariableSelectors(promptDiv, prompt);
            }
          } else {
            const index = this.selectedPrompts.indexOf(prompt);
            if (index > -1) {
              this.selectedPrompts.splice(index, 1);
              delete this.selectedVariables[prompt.name];
              const varContainer = promptDiv.querySelector(`.prompt-variables-${prompt.name.replace(/\s+/g, "-")}`);
              if (varContainer) varContainer.remove();
            }
          }
        }));
      });
    }
    const clipButton = contentEl.createEl("button", { text: "Clip" });
    clipButton.addEventListener("click", async () => {
      if (urlInput.value) {
        const normalizedUrl = normalizeUrl(urlInput.value);
        if (normalizedUrl) {
          if (this.selectedPrompts.length > 0) {
            this.close();
            new AIProcessingModal(
              this.app,
              this.plugin,
              normalizedUrl,
              categorySelect.value,
              this.selectedPrompts,
              this.selectedVariables,
              this.keepOriginalContent
            ).open();
          } else {
            await this.plugin.clipWebpage(
              normalizedUrl,
              categorySelect.value,
              null,
              {}
            );
            this.close();
          }
        }
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/adBlock.ts
var _AdBlocker = class _AdBlocker {
  constructor(settings) {
    this.settings = settings;
    this.filters = {
      domainBlocks: /* @__PURE__ */ new Set(),
      patternBlocks: [],
      elementBlocks: []
    };
    this.domainPatterns = [];
    this.combinedPattern = null;
    this.initialized = false;
    this.blockedDomains = /* @__PURE__ */ new Set();
    this.blockedPatterns = [];
    this.blockedRequest = /* @__PURE__ */ new Set();
    this.filterUrls = [
      "https://easylist.to/easylist/easylist.txt",
      "https://easylist.to/easylist/easyprivacy.txt",
      "https://easylist.to/easylist/fanboy-annoyance.txt",
      "https://easylist.to/easylist/fanboy-social.txt",
      "https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/filters.txt",
      "https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/badware.txt",
      "https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/privacy.txt",
      "https://raw.githubusercontent.com/uBlockOrigin/uAssets/refs/heads/master/filters/privacy.txt"
    ];
    if (!_AdBlocker.instance) {
      _AdBlocker.instance = this;
      this.initializeFilters();
    }
    return _AdBlocker.instance;
  }
  static async perload() {
    if (!this.instance) {
      this.instance = new _AdBlocker({});
      await this.instance.initializeFilters();
    }
  }
  async initializeFilters() {
    if (this.initialized) return;
    const responses = await Promise.all(
      this.filterUrls.map(async (url) => {
        try {
          const response = await fetch(url);
          return response.ok ? response.text() : "";
        } catch (e) {
          return "";
        }
      })
    );
    const rules = responses.join("\n").split("\n").filter((line) => line && !line.startsWith("!") && !line.startsWith("["));
    await Promise.all([
      this.processDomainRules(rules),
      this.processPatternRules(rules),
      this.processElementRules(rules)
    ]);
    this.domainPatterns = Array.from(this.filters.domainBlocks);
    this.combinedPattern = new RegExp(this.filters.patternBlocks.map((p) => p.source).join("|"), "i");
    this.initialized = true;
  }
  async processDomainRules(rules) {
    for (const rule of rules) {
      if (rule.startsWith("||")) {
        const domain = rule.substring(2).split("^")[0].split("*")[0];
        if (domain) this.filters.domainBlocks.add(domain);
      }
    }
  }
  async processPatternRules(rules) {
    for (const rule of rules) {
      if (rule.startsWith("/") && rule.endsWith("/")) {
        const pattern = rule.slice(1, -1);
        this.filters.patternBlocks.push(new RegExp(pattern, "i"));
      }
    }
  }
  async processElementRules(rules) {
    for (const rule of rules) {
      if (rule.startsWith("##")) {
        const selector = rule.substring(2);
        this.filters.elementBlocks.push(selector);
      }
    }
  }
  isAdRequest(url) {
    const urlObj = new URL(url);
    if (this.domainPatterns.some((pattern) => urlObj.hostname.includes(pattern))) {
      return true;
    }
    if (this.combinedPattern && this.combinedPattern.test(url)) {
      return true;
    }
    return false;
  }
  getDomainPatterns() {
    return this.domainPatterns;
  }
  getDOMFilterScript() {
    return `
           (function() {
                const isYouTube = window.location.hostname.includes('youtube.com');
                
                if (isYouTube) {
                    const handleVideoAds = () => {
                        const video = document.querySelector('video');
                        if (video) {
                            const isAd = document.querySelector('.ytp-ad-module, .ad-showing, .ad-interrupting') !== null ||
                                (video.currentSrc && (video.currentSrc.includes('/ad/') || video.currentSrc.includes('/adlog/'))) ||
                                (video.duration > 0 && video.duration <= 30 && video.currentTime === 0) ||
                                document.querySelector('.ytp-ad-player-overlay, .ytp-ad-message-container') !== null ||
                                document.querySelector('.video-ads') !== null;
                            
                            if (isAd) {
                                const skipButton = document.querySelector('.ytp-ad-skip-button, .ytp-ad-overlay-close-button');
                                if (skipButton) {
                                    skipButton.click();
                                    return;
                                }
                                
                                if (video.duration <= 30) {
                                    video.currentTime = video.duration;
                                    video.play();
                                }
                                
                                if (video.paused) {
                                    video.play();
                                }
                                
                                const adElements = document.querySelectorAll('.ytp-ad-player-overlay, .ytp-ad-message-container, .video-ads');
                                adElements.forEach(element => element.remove());
                            }
                        }
                    };

                    const videoObserver = new MutationObserver((mutations) => {
                        for (const mutation of mutations) {
                            if (mutation.type === 'childList' && 
                                (mutation.target.nodeName === 'VIDEO' || 
                                 mutation.target.classList.contains('ytp-ad-module') ||
                                 mutation.target.classList.contains('ytp-ad-player-overlay') ||
                                 mutation.target.classList.contains('video-ads'))) {
                                handleVideoAds();
                                break;
                            }
                        }
                    });

                    const containers = document.querySelectorAll('#movie_player, .html5-video-container, .video-ads');
                    containers.forEach(container => {
                        videoObserver.observe(container, {
                            childList: true,
                            subtree: true,
                            attributes: false
                        });
                    });

                    handleVideoAds();

                    const video = document.querySelector('video');
                    if (video) {
                        video.addEventListener('timeupdate', handleVideoAds);
                        video.addEventListener('play', handleVideoAds);
                        video.addEventListener('loadedmetadata', handleVideoAds);
                        video.addEventListener('progress', handleVideoAds);
                    }

                    if (video) {
                        video.addEventListener('play', () => {
                            if (video.paused) {
                                video.play();
                            }
                        });
                    }
                }
            })();
        `;
  }
  setupRequestInterception(webview) {
    const blockedRequests = /* @__PURE__ */ new Set();
    webview.addEventListener("will-request", (event) => {
      const url = event.url;
      const requestId = event.id;
      if (blockedRequests.has(requestId)) {
        event.preventDefault();
        return;
      }
      let hostname;
      try {
        hostname = new URL(url).hostname;
      } catch (e) {
        return;
      }
      if (this.blockedDomains.has(hostname)) {
        blockedRequests.add(requestId);
        event.preventDefault();
        return;
      }
      if (this.blockedPatterns.length > 0) {
        for (const pattern of this.blockedPatterns) {
          if (pattern.test(url)) {
            blockedRequests.add(requestId);
            event.preventDefault();
            return;
          }
        }
      }
    });
    webview.addEventListener("will-receive-headers", (event) => {
      var _a;
      const headers = event.headers;
      if (headers) {
        const contentType = (_a = headers["content-type"]) == null ? void 0 : _a.join(" ");
        if (contentType && /(ad|track|analytics)/i.test(contentType)) {
          blockedRequests.add(event.id);
          event.preventDefault();
        }
      }
    });
  }
  applyFilters(webview) {
    webview.executeJavaScript(this.getDOMFilterScript()).catch((error) => {
      console.error("Adblock script error:", error);
    });
    webview.insertCSS(this.getCSSBlockingRules());
  }
  getCSSBlockingRules() {
    return this.filters.elementBlocks.map((selector) => `${selector} { display: none !important; }`).join("\n");
  }
};
_AdBlocker.instance = null;
var AdBlocker = _AdBlocker;

// src/webViewComponent.ts
var remote;
if (!import_obsidian5.Platform.isMobileApp) {
  remote = require_renderer2();
}
var _WebViewComponent = class _WebViewComponent {
  constructor(app, url, settings = {}, onClipCallback, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.isFrameReady = false;
    this.navigationHistory = [];
    this.currentHistoryIndex = -1;
    this.eventListeners = [];
    this.frameDoc = null;
    var _a;
    this.url = url;
    this.settings = {
      defaultWidth: "100%",
      defaultHeight: "100%",
      searchEngine: "google",
      fitToContainer: true,
      ...settings
    };
    this.onClipCallback = onClipCallback;
    if (!_WebViewComponent.globalAdBlocker) {
      _WebViewComponent.globalAdBlocker = new AdBlocker((_a = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _a.adBlock);
    }
    this.adBlocker = _WebViewComponent.globalAdBlocker;
  }
  createContainer() {
    const containerEl = document.createElement("div");
    containerEl.classList.add("netClip_webview_container");
    const controlsEl = containerEl.createDiv("netClip_web_controls");
    this.setupNavigationBtns(controlsEl);
    this.setupSearchInput(controlsEl);
    this.setupClipBtn(controlsEl);
    this.setupFrameContainer(containerEl);
    this.navigationHistory.push(this.url);
    this.currentHistoryIndex = 0;
    return containerEl;
  }
  setupFrameContainer(containerEl) {
    const frameContainer = containerEl.createDiv("netClip_frame-container");
    this.loadingSpinner = frameContainer.createDiv("loading-spinner");
    this.frameDoc = frameContainer.ownerDocument;
    this.frame = this.createFrame();
    frameContainer.appendChild(this.frame);
    return frameContainer;
  }
  createFrame() {
    return import_obsidian5.Platform.isMobileApp ? this.createIframe() : this.createWebview();
  }
  createWebview() {
    var _a, _b, _c, _d, _e;
    const webview = ((_a = this.frameDoc) == null ? void 0 : _a.createElement("webview")) || document.createElement("webview");
    webview.classList.add("webview");
    webview.setAttribute("allowpopups", "");
    webview.setAttribute("webpreferences", "contextIsolation=yes, nodeIntegration=no");
    webview.setAttribute("plugins", "true");
    if (!((_c = (_b = this.plugin) == null ? void 0 : _b.settings) == null ? void 0 : _c.privateMode)) {
      webview.partition = "persist:netclip-shared";
    } else {
      const sessionId = `private-${Date.now()}`;
      webview.partition = `persist:${sessionId}`;
    }
    if ((_e = (_d = this.plugin) == null ? void 0 : _d.settings) == null ? void 0 : _e.privateMode) {
      webview.setAttribute("disablewebsecurity", "true");
      webview.setAttribute("disableblinkfeatures", "AutomationControlled");
      webview.setAttribute("disablefeatures", "Translate,NetworkService");
      webview.setAttribute("cookiestore", "private");
      webview.setAttribute("disablethirdpartycookies", "true");
    }
    webview.src = this.url;
    webview.addEventListener("destroyed", () => {
      const parent = webview.parentElement;
      if (parent && parent.ownerDocument !== this.frameDoc) {
        this.cleanupWebview(webview);
        this.frameDoc = parent.ownerDocument;
        const newWebview = this.createWebview();
        parent.appendChild(newWebview);
        this.frame = newWebview;
        this.setupWebviewEvents(newWebview);
      }
    });
    this.setupWebviewEvents(webview);
    return webview;
  }
  cleanupWebview(webview) {
    if (webview) {
      try {
        webview.remove();
      } catch (e) {
      }
    }
  }
  setupSearchInput(container) {
    const searchContainer = container.createDiv("netClip_search_container");
    this.searchInput = searchContainer.createEl("input", { type: "text", placeholder: "Search...", value: this.url });
    const suggestionContainer = searchContainer.createDiv("netClip_query_box");
    const suggestionsBox = suggestionContainer.createDiv("netClip_suggestions");
    this.search = new WebSearch(
      this.searchInput,
      suggestionContainer,
      suggestionsBox,
      { searchEngine: this.settings.searchEngine }
    );
    this.searchInput.addEventListener("search-query", (event) => {
      const { url } = event.detail;
      this.navigateTo(url);
    });
  }
  setupClipBtn(container) {
    const clipContianer = container.createDiv("netClip_clip_btn_container");
    if (this.onClipCallback) {
      this.clipBtn = clipContianer.createEl("button", {
        text: "Quick clip",
        cls: "netClip_quick_clip_btn netClip_btn"
      });
      (0, import_obsidian5.setIcon)(this.clipBtn, "folder-down");
      (0, import_obsidian5.setTooltip)(this.clipBtn, "Quick save");
      this.clipBtn.onclick = () => {
        var _a;
        (_a = this.onClipCallback) == null ? void 0 : _a.call(this, this.getCurrentUrl());
      };
    }
    if (this.plugin) {
      this.modalClipBtn = clipContianer.createEl("button", {
        cls: "netClip_modal_clip_btn netClip_btn"
      });
      (0, import_obsidian5.setIcon)(this.modalClipBtn, "folder-symlink");
      (0, import_obsidian5.setTooltip)(this.modalClipBtn, "Save to...");
      this.modalClipBtn.onclick = () => {
        if (this.plugin) {
          const modal = new ClipModal(this.app, this.plugin);
          modal.tryGetClipboardUrl = async () => this.getCurrentUrl();
          modal.open();
        }
      };
    }
  }
  setupNavigationBtns(container) {
    const leftContainer = container.createDiv("netClip_nav_left");
    this.backBtn = leftContainer.createEl("button", { cls: "netClip_back_btn netClip_btn" });
    (0, import_obsidian5.setIcon)(this.backBtn, "chevron-left");
    this.backBtn.onclick = () => this.goBack();
    this.backBtn.disabled = true;
    this.forwardBtn = leftContainer.createEl("button", { cls: "netClip_forward_btn netClip_btn" });
    (0, import_obsidian5.setIcon)(this.forwardBtn, "chevron-right");
    this.forwardBtn.onclick = () => this.goForward();
    this.forwardBtn.disabled = true;
    this.refreshBtn = leftContainer.createEl("button", { cls: "netClip_refresh_btn netClip_btn" });
    (0, import_obsidian5.setIcon)(this.refreshBtn, "rotate-ccw");
    this.refreshBtn.onclick = () => this.refresh();
  }
  createIframe() {
    var _a, _b;
    const iframe = document.createElement("iframe");
    iframe.setAttribute("allowpopups", "");
    iframe.setAttribute("credentialless", "true");
    iframe.setAttribute("crossorigin", "anonymous");
    iframe.setAttribute("src", this.url);
    let sandbox = "allow-forms allow-modals allow-popups allow-presentation allow-scripts allow-top-navigation-by-user-activation";
    if (!((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.privateMode)) {
      sandbox += " allow-same-origin";
    }
    iframe.setAttribute("sandbox", sandbox);
    iframe.setAttribute("allow", "encrypted-media;fullscreen;oversized-images;picture-in-picture;sync-xhr;geolocation");
    iframe.addEventListener("load", () => {
      var _a2, _b2, _c, _d;
      this.onFrameLoad();
      if ((_c = (_b2 = (_a2 = this.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b2.adBlock) == null ? void 0 : _c.enabled) {
        setTimeout(() => {
          if (iframe.contentDocument) {
            this.adBlocker.applyFilters(iframe);
          }
        }, 500);
      }
      const title = (_d = iframe.contentDocument) == null ? void 0 : _d.title;
      if (title && this.titleChangeCallback) {
        this.titleChangeCallback(title);
      }
    });
    return iframe;
  }
  setupWebviewEvents(webview) {
    webview.addEventListener("dom-ready", () => {
      var _a, _b, _c, _d, _e;
      this.isFrameReady = true;
      this.updateUrlDisplay();
      this.loadingSpinner.classList.remove("loading-spinner-visible");
      const webContents = remote.webContents.fromId(webview.getWebContentsId());
      webContents.setWindowOpenHandler(({ url }) => {
        var _a2, _b2;
        if (this.windowOpenCallback) {
          this.windowOpenCallback(url);
          return { action: "deny" };
        }
        if ((_b2 = (_a2 = this.plugin) == null ? void 0 : _a2.settings) == null ? void 0 : _b2.privateMode) {
          this.createNewPrivateWindow(url);
          return { action: "deny" };
        }
        return {
          action: "allow",
          overrideBrowserWindowOptions: {
            width: 800,
            height: 600,
            webPreferences: {
              nodeIntegration: false,
              contextIsolation: true,
              webSecurity: true,
              partition: webview.partition,
              javascript: true,
              plugins: true,
              webgl: true
            }
          }
        };
      });
      if ((_c = (_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.adBlock) == null ? void 0 : _c.enabled) {
        this.setupAdBlocking(webview);
      }
      if ((_e = (_d = this.plugin) == null ? void 0 : _d.settings) == null ? void 0 : _e.privateMode) {
        this.setupPrivateMode(webview);
      }
    });
    webview.addEventListener("did-start-loading", () => {
      this.loadingSpinner.classList.add("loading-spinner-visible");
    });
    webview.addEventListener("did-stop-loading", () => {
      this.loadingSpinner.classList.remove("loading-spinner-visible");
    });
    webview.addEventListener("did-navigate", () => {
      this.updateUrlDisplay();
      this.updateNavigationButtons();
    });
    webview.addEventListener("did-navigate-in-page", () => {
      this.updateUrlDisplay();
      this.updateNavigationButtons();
    });
    webview.addEventListener("page-title-updated", (event) => {
      if (this.titleChangeCallback) {
        this.titleChangeCallback(event.title);
      }
    });
    webview.addEventListener("did-fail-load", (event) => {
      this.loadingSpinner.classList.remove("loading-spinner-visible");
    });
  }
  createNewPrivateWindow(url) {
    const container = document.createElement("div");
    container.classList.add("netClip_webview_container");
    const controlsEl = container.createDiv("netClip_web_controls");
    this.setupNavigationBtns(controlsEl);
    this.setupSearchInput(controlsEl);
    this.setupClipBtn(controlsEl);
    const frameContainer = container.createDiv("netClip_frame-container");
    const newWebview = this.createWebview();
    newWebview.src = url;
    frameContainer.appendChild(newWebview);
    document.body.appendChild(container);
    container.style.position = "fixed";
    container.style.top = "50%";
    container.style.left = "50%";
    container.style.transform = "translate(-50%, -50%)";
    container.style.width = "80%";
    container.style.height = "80%";
    container.style.zIndex = "1000";
  }
  onFrameLoad() {
    this.isFrameReady = true;
    this.updateUrlDisplay();
    const currentUrl = this.getCurrentUrl();
    if (currentUrl !== this.navigationHistory[this.currentHistoryIndex]) {
      this.navigationHistory = this.navigationHistory.slice(0, this.currentHistoryIndex + 1);
      this.navigationHistory.push(currentUrl);
      this.currentHistoryIndex++;
      this.updateNavigationButtons();
    }
  }
  navigateTo(url) {
    this.url = url;
    this.navigationHistory.push(this.url);
    this.currentHistoryIndex = this.navigationHistory.length - 1;
    this.frame.src = this.url;
    this.updateUrlDisplay();
  }
  getCurrentUrl() {
    var _a;
    if (this.frame instanceof HTMLIFrameElement) {
      return ((_a = this.frame.contentWindow) == null ? void 0 : _a.location.href) || this.url;
    } else if (this.frame && typeof this.frame.getURL === "function") {
      return this.frame.getURL() || this.url;
    }
    return this.url;
  }
  updateUrlDisplay() {
    const currentUrl = this.getCurrentUrl();
    this.url = currentUrl;
    if (this.searchInput) {
      this.searchInput.value = currentUrl;
    }
  }
  updateNavigationButtons() {
    var _a, _b;
    if (this.frame instanceof HTMLIFrameElement) {
      this.backBtn.disabled = this.currentHistoryIndex <= 0;
      this.forwardBtn.disabled = this.currentHistoryIndex >= this.navigationHistory.length - 1;
    } else {
      const webview = this.frame;
      this.backBtn.disabled = !((_a = webview.canGoBack) == null ? void 0 : _a.call(webview));
      this.forwardBtn.disabled = !((_b = webview.canGoForward) == null ? void 0 : _b.call(webview));
    }
  }
  goBack() {
    var _a, _b;
    if (this.isFrameReady) {
      this.loadingSpinner.classList.add("loading-spinner-visible");
      if (this.frame instanceof HTMLIFrameElement) {
        if (this.currentHistoryIndex > 0) {
          this.currentHistoryIndex--;
          this.frame.src = this.navigationHistory[this.currentHistoryIndex];
        }
      } else {
        const webview = this.frame;
        if ((_a = webview.canGoBack) == null ? void 0 : _a.call(webview)) {
          (_b = webview.goBack) == null ? void 0 : _b.call(webview);
        }
      }
    }
  }
  goForward() {
    var _a, _b;
    if (this.isFrameReady) {
      this.loadingSpinner.classList.add("loading-spinner-visible");
      if (this.frame instanceof HTMLIFrameElement) {
        if (this.currentHistoryIndex < this.navigationHistory.length - 1) {
          this.currentHistoryIndex++;
          this.frame.src = this.navigationHistory[this.currentHistoryIndex];
        }
      } else {
        const webview = this.frame;
        if ((_a = webview.canGoForward) == null ? void 0 : _a.call(webview)) {
          (_b = webview.goForward) == null ? void 0 : _b.call(webview);
        }
      }
    }
  }
  refresh() {
    var _a;
    if (this.isFrameReady) {
      this.loadingSpinner.classList.add("loading-spinner-visible");
      if (this.frame instanceof HTMLIFrameElement) {
        (_a = this.frame.contentWindow) == null ? void 0 : _a.location.reload();
      } else {
        this.frame.reload();
      }
    }
  }
  onTitleChange(callback) {
    this.titleChangeCallback = callback;
  }
  onWindowOpen(callback) {
    this.windowOpenCallback = callback;
  }
  setupAdBlocking(webview) {
    this.adBlocker.initializeFilters().then(() => {
      this.adBlocker.applyFilters(webview);
      webview.addEventListener("dom-ready", () => {
        webview.executeJavaScript(this.adBlocker.getDOMFilterScript()).catch((error) => {
        });
      });
    });
  }
  setupPrivateMode(webview) {
    webview.executeJavaScript(`
            window.sessionStorage.clear();
            window.localStorage.clear();
            
            // Override storage APIs
            Object.defineProperties(window, {
                'localStorage': {
                    value: undefined
                },
                'sessionStorage': {
                    value: undefined
                }
            });
            
            // Clear cookies
            document.cookie.split(';').forEach(cookie => {
                const eqPos = cookie.indexOf('=');
                const name = eqPos > -1 ? cookie.substr(0, eqPos) : cookie;
                document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT';
            });
        `).catch(console.error);
    const webContents = remote.webContents.fromId(webview.getWebContentsId());
    webContents.session.webRequest.onBeforeSendHeaders((details, callback) => {
      const requestHeaders = {
        ...details.requestHeaders,
        "DNT": "1",
        "Sec-GPC": "1"
      };
      callback({ requestHeaders });
    });
  }
  addEventListenerWithCleanup(element, type, listener) {
    element.addEventListener(type, listener);
    this.eventListeners.push({ element, type, listener });
  }
  unload() {
    this.eventListeners.forEach(({ element, type, listener }) => {
      element.removeEventListener(type, listener);
    });
    this.eventListeners = [];
    if (this.frame) {
      this.frame.remove();
    }
    if (this.search) {
      this.search.unload();
    }
  }
};
_WebViewComponent.globalAdBlocker = null;
var WebViewComponent = _WebViewComponent;

// src/view/ModalWebView.ts
var WebViewModal = class extends import_obsidian6.Modal {
  constructor(app, url, plugin) {
    var _a;
    super(app);
    this.plugin = plugin;
    this.modalEl.addClass("netclip_modal");
    this.webViewComponent = new WebViewComponent(
      this.app,
      url,
      {
        searchEngine: ((_a = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _a.searchEngine) || "default"
      },
      async (clipUrl) => {
        if (this.plugin && typeof this.plugin.clipWebpage === "function") {
          await this.plugin.clipWebpage(clipUrl);
        } else {
          new import_obsidian6.Notice("Clip webpage function not available");
        }
      },
      this.plugin
    );
  }
  onOpen() {
    const { contentEl } = this;
    const webViewContainer = this.webViewComponent.createContainer();
    contentEl.appendChild(webViewContainer);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/view/EditorWebView.ts
var import_obsidian7 = require("obsidian");
var VIEW_TYPE_WORKSPACE_WEBVIEW = "netClip_workspace_webview";
var WorkspaceLeafWebView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.initialUrl = "";
    this.icon = "globe";
    this.currentTitle = "Web View";
    this.plugin = plugin;
    this.onLoadEvent = new Promise((resolve) => {
      this.resolveLoadEvent = resolve;
    });
  }
  setUrl(url) {
    this.initialUrl = url;
    this.reloadWebView();
  }
  getViewType() {
    return VIEW_TYPE_WORKSPACE_WEBVIEW;
  }
  getDisplayText() {
    return this.currentTitle;
  }
  reloadWebView() {
    this.containerEl.empty();
    this.createWebViewComponent();
  }
  async setState(state, result) {
    if (state == null ? void 0 : state.url) {
      this.initialUrl = state.url;
      this.reloadWebView();
    }
    super.setState(state, result);
  }
  createWebViewComponent() {
    this.webViewComponent = new WebViewComponent(
      this.app,
      this.initialUrl,
      {
        searchEngine: this.plugin.settings.searchEngine
      },
      async (clipUrl) => {
        if (this.plugin && typeof this.plugin.clipWebpage === "function") {
          await this.plugin.clipWebpage(clipUrl);
        } else {
          new import_obsidian7.Notice("Clip webpage function not available");
        }
      },
      this.plugin
    );
    this.webViewComponent.onWindowOpen((url) => {
      const leaf = this.app.workspace.getLeaf(true);
      leaf.setViewState({
        type: VIEW_TYPE_WORKSPACE_WEBVIEW,
        state: { url }
      });
      this.app.workspace.revealLeaf(leaf);
    });
    const containerEl = this.webViewComponent.createContainer();
    this.webViewComponent.onTitleChange((title) => {
      this.currentTitle = title;
      this.leaf.setViewState({
        type: VIEW_TYPE_WORKSPACE_WEBVIEW,
        state: { title }
      });
    });
    this.containerEl.appendChild(containerEl);
  }
  async onOpen() {
    var _a;
    this.containerEl = this.containerEl.children[1];
    this.containerEl.empty();
    const state = this.leaf.getViewState();
    if (((_a = state.state) == null ? void 0 : _a.url) && typeof state.state.url === "string") {
      this.initialUrl = state.state.url;
    } else {
      this.initialUrl = this.plugin.settings.defaultWebUrl || "https://google.com";
    }
    this.createWebViewComponent();
    this.resolveLoadEvent();
  }
  async onClose() {
    this.containerEl.empty();
  }
};

// src/contextMenu.ts
var ClipperContextMenu = class {
  constructor(app, file, onDelete, onOpenArticle, url) {
    this.app = app;
    this.file = file;
    this.url = url;
    this.onDelete = onDelete;
    this.onOpenArticle = onOpenArticle;
    this.plugin = this.app.plugins.getPlugin("net-clip");
  }
  show(anchorElement) {
    const menu = new import_obsidian8.Menu();
    menu.addItem((item) => {
      item.setTitle("Open page in editor").setIcon("globe").onClick(async () => {
        if (this.url) {
          const existingLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_WORKSPACE_WEBVIEW);
          for (const leaf2 of existingLeaves) {
            await leaf2.view.onLoadEvent;
            if (leaf2.view instanceof WorkspaceLeafWebView && leaf2.view.url === this.url) {
              this.app.workspace.setActiveLeaf(leaf2, { focus: true });
              return;
            }
          }
          const leaf = this.app.workspace.getLeaf("tab");
          await leaf.setViewState({
            type: VIEW_TYPE_WORKSPACE_WEBVIEW,
            state: { url: this.url }
          });
          await leaf.view.onLoadEvent;
          if (leaf.view instanceof WorkspaceLeafWebView) {
            leaf.view.setUrl(this.url);
            this.app.workspace.setActiveLeaf(leaf, { focus: true });
          }
        } else {
          new import_obsidian8.Notice("No URL found for this clipping");
        }
      });
    });
    menu.addItem((item) => {
      item.setTitle("Open page in modal").setIcon("maximize").onClick(() => {
        if (this.url) {
          const modal = new WebViewModal(
            this.app,
            this.url,
            this.plugin
          );
          modal.open();
        } else {
          new import_obsidian8.Notice("No URL found for this clipping");
        }
      });
    });
    menu.addItem((item) => {
      item.setTitle("Open in editor").setIcon("file-text").onClick(() => {
        this.onOpenArticle(this.file);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Delete").setIcon("trash").onClick(() => {
        this.onDelete(this.file);
      });
    });
    const rect = anchorElement.getBoundingClientRect();
    menu.showAtPosition({ x: rect.left, y: rect.bottom });
  }
};

// src/assets/image.ts
var DEFAULT_IMAGE = `data:image/svg+xml;base64,${btoa(`<svg width="214" height="207" viewBox="0 0 214 207" fill="none" xmlns="http://www.w3.org/2000/svg">
    <rect width="214" height="207" fill="#D3B1EA"/>
    <path d="M150.308 60H65.6923C63.6522 60 61.6956 60.8104 60.253 62.253C58.8104 63.6956 58 65.6522 58 67.6923V136.923C58 138.963 58.8104 140.92 60.253 142.362C61.6956 143.805 63.6522 144.615 65.6923 144.615H150.308C152.348 144.615 154.304 143.805 155.747 142.362C157.19 140.92 158 138.963 158 136.923V67.6923C158 65.6522 157.19 63.6956 155.747 62.253C154.304 60.8104 152.348 60 150.308 60ZM150.308 67.6923V117.091L137.774 104.563C137.06 103.848 136.212 103.281 135.278 102.895C134.345 102.508 133.344 102.309 132.334 102.309C131.324 102.309 130.323 102.508 129.39 102.895C128.457 103.281 127.609 103.848 126.894 104.563L117.279 114.178L96.125 93.024C94.6826 91.5825 92.7268 90.7728 90.6875 90.7728C88.6482 90.7728 86.6924 91.5825 85.25 93.024L65.6923 112.582V67.6923H150.308ZM65.6923 123.462L90.6923 98.4615L129.154 136.923H65.6923V123.462ZM150.308 136.923H140.034L122.726 119.615L132.341 110L150.308 127.971V136.923ZM115.692 88.8462C115.692 87.7051 116.031 86.5897 116.665 85.6409C117.299 84.6922 118.2 83.9527 119.254 83.5161C120.308 83.0794 121.468 82.9652 122.587 83.1878C123.706 83.4104 124.734 83.9599 125.541 84.7667C126.348 85.5735 126.897 86.6015 127.12 87.7206C127.343 88.8398 127.228 89.9998 126.792 91.0539C126.355 92.1081 125.615 93.0092 124.667 93.6431C123.718 94.277 122.603 94.6154 121.462 94.6154C119.931 94.6154 118.464 94.0076 117.382 92.9256C116.3 91.8437 115.692 90.3762 115.692 88.8462Z" fill="#8E6FB6"/>
</svg>`)}`;

// src/view/ClipperView.ts
var import_obsidian10 = require("obsidian");

// src/translations.ts
function t(key) {
  const storeLang = window.localStorage.getItem("language");
  const lang = storeLang || "en";
  const translation = TRANSLATIONS[lang] || TRANSLATIONS["en"];
  return translation[key];
}
var TRANSLATIONS = {
  en: {
    "clipper_view": "Clipper View",
    "search_saved_articles": "Search saved articles...",
    "sort_a_z": "A-Z",
    "sort_z_a": "Z-A",
    "sort_newest_first": "Newest First",
    "sort_oldest_first": "Oldest First",
    "all": "All",
    "unknown_source": "Unknown source",
    "no_matching_articles": "No matching articles found.",
    "clip_webpage": "Clip webpage",
    "url": "Url:",
    "enter_url": "Enter URL to clip...",
    "save_to": "Save to:",
    "clip": "Clip",
    "confirm_delete": "Confirm delete",
    "confirm_delete_message": 'Are you sure you want to delete the article "{0}"?',
    "delete": "Delete",
    "cancel": "Cancel",
    "select_parent_folder": "Select Parent Folder",
    "select_parent_folder_desc": "Choose a parent folder for NetClip content. Leave empty to use vault root.",
    "vault_root": "Vault Root",
    "store_in_root_desc": "Store NetClip content directly in the vault root",
    "available_folders": "Available Folders",
    "select": "Select",
    "web_view": "Web view",
    "search_engine": "Search engine",
    "search_engine_desc": "Choose the default search engine for search queries",
    "default_url": "Default url",
    "default_url_desc": "Set the default URL opened when using the web modal/editor",
    "enter_default_url": "Enter default URL",
    "invalid_url": "Invalid URL. Please enter a valid URL.",
    "enable_ad_blocking": "Enable ad blocking (experimental)",
    "enable_ad_blocking_desc": "Block ads in web view",
    "private_mode": "Private mode",
    "private_mode_desc": "Block cookies, localStorage, and other tracking mechanisms (prevents saving browsing data)",
    "clipper": "Clipper",
    "ai_prompts_tab": "AI prompts",
    "view_position": "View position",
    "view_position_desc": "Choose where the Web Clipper view should appear",
    "left_sidebar": "Left sidebar",
    "right_sidebar": "Right sidebar",
    "default_position": "Default position",
    "change_folder_name": "Change folder name",
    "change_folder_name_desc": "Change the folder for saving clipped articles",
    "enter_folder_name": "Enter folder name",
    "confirm": "Confirm",
    "folder_renamed": 'Folder renamed to "{0}"',
    "categories": "Categories",
    "categories_desc": "Create new category folder",
    "new_category_name": "New category name",
    "create": "Create",
    "please_enter_category_name": "Please enter a category name",
    "category_exists": 'Category "{0}" already exists',
    "category_created": 'Category "{0}" created successfully',
    "category_deleted": 'Category "{0}" deleted successfully',
    "enter_icon_name": "Enter icon name",
    "folder_not_found": 'Folder "{0}" not found.',
    "folder_exists": 'Folder "{0}" already exists.',
    "web_view_tab": "Web view",
    "clipper_tab": "Clipper",
    "parent_folder": "Parent folder",
    "parent_folder_desc": "Choose a parent folder for NetClip content (leave empty to use vault root)",
    "parent_folder_path": "Parent folder path",
    "browse": "Browse",
    "sort_by": "Sort by",
    "domain_filter": "Filter by domain",
    "all_domains": "All domains",
    "open_web": "Open web view",
    "open_settings": "Open settings",
    "add_clip": "Add new clip",
    "current_icon": "Current icon: {0}",
    "enable_ai": "Enable AI Processing",
    "enable_ai_desc": "Enable AI-powered content processing using Gemini API",
    "gemini_api_key": "Gemini API Key",
    "gemini_api_key_desc": "Enter your Gemini API key",
    "enter_api_key": "Enter API key",
    "ai_prompts": "AI Prompts",
    "ai_prompts_desc": "Create and manage AI processing prompts",
    "add_new_prompt": "Add New Prompt",
    "edit_prompt": "Edit",
    "delete_prompt": "Delete",
    "export_prompts": "Export All Prompts",
    "import_prompts": "Import Prompts",
    "export_prompts_desc": "Export all AI prompts as a JSON file",
    "import_prompts_desc": "Import AI prompts from a JSON file",
    "import_success": "Successfully imported prompts",
    "import_error": "Error importing prompts: Invalid file format",
    "export_prompt": "Export",
    "export_single_prompt_desc": "Export this prompt as a JSON file",
    "show_in_clipper": "Show in clipper",
    "show_in_clipper_desc": "Show this prompt in the clip modal when clipping content",
    "hide_in_clipper": "Hide in clipper",
    "hide_in_clipper_desc": "Hide this prompt from the clip modal",
    "support_tab": "Support",
    "github_repo": "GitHub Repository",
    "github_repo_desc": "Visit the GitHub repository for documentation, issues, and updates",
    "open_github": "Open GitHub",
    "support_development": "Support Development",
    "support_development_desc": "If this plugin is useful to you, consider supporting its development or giving it a star on GitHub!",
    "buy_coffee": "Buy Me a Coffee",
    "buy_coffee_desc": "Support me on Buy Me a Coffee",
    "support_kofi": "Support on Ko-fi",
    "support_kofi_desc": "Support me on Ko-fi",
    "home_tab": "Home tab",
    "show_clock": "Show clock",
    "show_recent_files": "Show recent files",
    "show_saved_articles": "Show saved articles",
    "replace_new_tabs": "Replace new tabs",
    "replace_new_tabs_desc": "When enabled, new empty tabs will be replaced with the NetClip home tab",
    "show_clock_desc": "Show a clock on the home tab",
    "show_recent_files_desc": "Display the recent files section on the home tab",
    "show_saved_articles_desc": "Display the saved articles section on the home tab"
  },
  "ja": {
    "clipper_view": "\u30AF\u30EA\u30C3\u30D1\u30FC\u30D3\u30E5\u30FC",
    "search_saved_articles": "\u4FDD\u5B58\u3055\u308C\u305F\u8A18\u4E8B\u3092\u691C\u7D22...",
    "sort_a_z": "A-Z",
    "sort_z_a": "Z-A",
    "sort_newest_first": "\u65B0\u3057\u3044\u9806",
    "sort_oldest_first": "\u53E4\u3044\u9806",
    "all": "\u3059\u3079\u3066",
    "unknown_source": "\u4E0D\u660E\u306A\u30BD\u30FC\u30B9",
    "no_matching_articles": "\u4E00\u81F4\u3059\u308B\u8A18\u4E8B\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002",
    "clip_webpage": "\u30A6\u30A7\u30D6\u30DA\u30FC\u30B8\u3092\u30AF\u30EA\u30C3\u30D7",
    "url": "URL:",
    "enter_url": "\u30AF\u30EA\u30C3\u30D7\u3059\u308BURL\u3092\u5165\u529B...",
    "save_to": "\u4FDD\u5B58\u5148:",
    "clip": "\u30AF\u30EA\u30C3\u30D7",
    "confirm_delete": "\u524A\u9664\u306E\u78BA\u8A8D",
    "confirm_delete_message": "\u8A18\u4E8B\u300C{0}\u300D\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F",
    "delete": "\u524A\u9664",
    "cancel": "\u30AD\u30E3\u30F3\u30BB\u30EB",
    "clipping": "\u30AF\u30EA\u30C3\u30D7\u4E2D...",
    "clipping_success": "{0} \u306E\u30AF\u30EA\u30C3\u30D7\u306B\u6210\u529F\u3057\u307E\u3057\u305F",
    "clipping_failed": "\u30AF\u30EA\u30C3\u30D7\u306B\u5931\u6557\u3057\u307E\u3057\u305F: {0}",
    "created_folders": "{0} \u306B\u30D5\u30A9\u30EB\u30C0\u3092\u4F5C\u6210\u3057\u307E\u3057\u305F",
    "no_url_found": "\u3053\u306E\u30AF\u30EA\u30C3\u30D7\u306BURL\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093",
    "clip_webpage_function_not_available": "\u30AF\u30EA\u30C3\u30D7\u6A5F\u80FD\u304C\u5229\u7528\u3067\u304D\u307E\u305B\u3093",
    "select_parent_folder": "\u89AA\u30D5\u30A9\u30EB\u30C0\u3092\u9078\u629E",
    "select_parent_folder_desc": "NetClip\u30B3\u30F3\u30C6\u30F3\u30C4\u306E\u89AA\u30D5\u30A9\u30EB\u30C0\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u7A7A\u767D\u306E\u5834\u5408\u306Fvault\u30EB\u30FC\u30C8\u3092\u4F7F\u7528\u3057\u307E\u3059\u3002",
    "vault_root": "Vault\u30EB\u30FC\u30C8",
    "store_in_root_desc": "NetClip\u30B3\u30F3\u30C6\u30F3\u30C4\u3092Vault\u30EB\u30FC\u30C8\u306B\u76F4\u63A5\u4FDD\u5B58",
    "available_folders": "\u5229\u7528\u53EF\u80FD\u306A\u30D5\u30A9\u30EB\u30C0",
    "select": "\u9078\u629E",
    "web_view": "\u30A6\u30A7\u30D6\u30D3\u30E5\u30FC",
    "search_engine": "\u691C\u7D22\u30A8\u30F3\u30B8\u30F3",
    "search_engine_desc": "\u691C\u7D22\u30AF\u30A8\u30EA\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u691C\u7D22\u30A8\u30F3\u30B8\u30F3\u3092\u9078\u629E",
    "default_url": "\u30C7\u30D5\u30A9\u30EB\u30C8URL",
    "default_url_desc": "\u30A6\u30A7\u30D6\u30E2\u30FC\u30C0\u30EB/\u30A8\u30C7\u30A3\u30BF\u3067\u958B\u304F\u30C7\u30D5\u30A9\u30EB\u30C8URL\u3092\u8A2D\u5B9A",
    "enter_default_url": "\u30C7\u30D5\u30A9\u30EB\u30C8URL\u3092\u5165\u529B",
    "invalid_url": "\u7121\u52B9\u306AURL\u3067\u3059\u3002\u6709\u52B9\u306AURL\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    "enable_ad_blocking": "\u5E83\u544A\u30D6\u30ED\u30C3\u30AF\u6A5F\u80FD\u3092\u6709\u52B9\u306B\u3059\u308B\uFF08\u5B9F\u9A13\u7684\uFF09",
    "enable_ad_blocking_desc": "\u30A6\u30A7\u30D6\u30D3\u30E5\u30FC\u3067\u5E83\u544A\u3092\u30D6\u30ED\u30C3\u30AF",
    "private_mode": "\u30D7\u30E9\u30A4\u30D9\u30FC\u30C8\u30E2\u30FC\u30C9",
    "private_mode_desc": "Cookie\u3001localStorage\u3001\u305D\u306E\u4ED6\u306E\u8FFD\u8DE1\u30E1\u30AB\u30CB\u30BA\u30E0\u3092\u30D6\u30ED\u30C3\u30AF\uFF08\u95B2\u89A7\u30C7\u30FC\u30BF\u306E\u4FDD\u5B58\u3092\u9632\u6B62\uFF09",
    "clipper": "\u30AF\u30EA\u30C3\u30D1\u30FC",
    "ai_prompts_tab": "AI \u30D7\u30ED\u30F3\u30D7\u30C8",
    "view_position": "\u30D3\u30E5\u30FC\u4F4D\u7F6E",
    "view_position_desc": "Web\u30AF\u30EA\u30C3\u30D1\u30FC\u30D3\u30E5\u30FC\u3092\u8868\u793A\u3059\u308B\u5834\u6240\u3092\u9078\u629E",
    "left_sidebar": "\u5DE6\u30B5\u30A4\u30C9\u30D0\u30FC",
    "right_sidebar": "\u53F3\u30B5\u30A4\u30C9\u30D0\u30FC",
    "default_position": "\u30C7\u30D5\u30A9\u30EB\u30C8\u4F4D\u7F6E",
    "change_folder_name": "\u30D5\u30A9\u30EB\u30C0\u540D\u3092\u5909\u66F4",
    "change_folder_name_desc": "\u30AF\u30EA\u30C3\u30D7\u3057\u305F\u8A18\u4E8B\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u3092\u5909\u66F4",
    "enter_folder_name": "\u30D5\u30A9\u30EB\u30C0\u540D\u3092\u5165\u529B",
    "confirm": "\u78BA\u8A8D",
    "folder_renamed": "\u30D5\u30A9\u30EB\u30C0\u540D\u3092\u300C{0}\u300D\u306B\u5909\u66F4\u3057\u307E\u3057\u305F",
    "categories": "\u30AB\u30C6\u30B4\u30EA",
    "categories_desc": "\u65B0\u3057\u3044\u30AB\u30C6\u30B4\u30EA\u30D5\u30A9\u30EB\u30C0\u3092\u4F5C\u6210",
    "new_category_name": "\u65B0\u3057\u3044\u30AB\u30C6\u30B4\u30EA\u540D",
    "create": "\u4F5C\u6210",
    "please_enter_category_name": "\u30AB\u30C6\u30B4\u30EA\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044",
    "category_exists": "\u30AB\u30C6\u30B4\u30EA\u300C{0}\u300D\u306F\u3059\u3067\u306B\u5B58\u5728\u3057\u307E\u3059",
    "category_created": "\u30AB\u30C6\u30B4\u30EA\u300C{0}\u300D\u304C\u6B63\u5E38\u306B\u4F5C\u6210\u3055\u308C\u307E\u3057\u305F",
    "category_deleted": "\u30AB\u30C6\u30B4\u30EA\u300C{0}\u300D\u304C\u6B63\u5E38\u306B\u524A\u9664\u3055\u308C\u307E\u3057\u305F",
    "enter_icon_name": "\u30A2\u30A4\u30B3\u30F3\u540D\u3092\u5165\u529B",
    "folder_not_found": "\u30D5\u30A9\u30EB\u30C0\u300C{0}\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002",
    "folder_exists": "\u30D5\u30A9\u30EB\u30C0\u300C{0}\u300D\u306F\u3059\u3067\u306B\u5B58\u5728\u3057\u307E\u3059",
    "web_view_tab": "\u30A6\u30A7\u30D6\u30D3\u30E5\u30FC",
    "clipper_tab": "\u30AF\u30EA\u30C3\u30D1\u30FC",
    "parent_folder": "\u89AA\u30D5\u30A9\u30EB\u30C0",
    "parent_folder_desc": "NetClip\u30B3\u30F3\u30C6\u30F3\u30C4\u306E\u89AA\u30D5\u30A9\u30EB\u30C0\u3092\u9078\u629E\uFF08\u7A7A\u767D\u306E\u5834\u5408\u306Fvault\u30EB\u30FC\u30C8\u3092\u4F7F\u7528\uFF09",
    "parent_folder_path": "\u89AA\u30D5\u30A9\u30EB\u30C0\u306E\u30D1\u30B9",
    "browse": "\u53C2\u7167",
    "sort_by": "\u4E26\u3073\u66FF\u3048",
    "domain_filter": "\u30C9\u30E1\u30A4\u30F3\u3067\u30D5\u30A3\u30EB\u30BF\u30FC",
    "all_domains": "\u3059\u3079\u3066\u306E\u30C9\u30E1\u30A4\u30F3",
    "open_web": "\u30A6\u30A7\u30D6\u30D3\u30E5\u30FC\u3092\u958B\u304F",
    "open_settings": "\u8A2D\u5B9A\u3092\u958B\u304F",
    "add_clip": "\u65B0\u898F\u30AF\u30EA\u30C3\u30D7\u3092\u8FFD\u52A0",
    "current_icon": "\u73FE\u5728\u306E\u30A2\u30A4\u30B3\u30F3: {0}",
    "enable_ai": "AI\u51E6\u7406\u3092\u6709\u52B9\u306B\u3059\u308B",
    "enable_ai_desc": "Gemini API\u3092\u4F7F\u7528\u3057\u305FAI\u51E6\u7406\u3092\u6709\u52B9\u306B\u3059\u308B",
    "gemini_api_key": "Gemini API\u30AD\u30FC",
    "gemini_api_key_desc": "Gemini API\u30AD\u30FC\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044",
    "enter_api_key": "API\u30AD\u30FC\u3092\u5165\u529B",
    "ai_prompts": "AI\u30D7\u30ED\u30F3\u30D7\u30C8",
    "ai_prompts_desc": "AI\u51E6\u7406\u30D7\u30ED\u30F3\u30D7\u30C8\u306E\u4F5C\u6210\u3068\u7BA1\u7406",
    "add_new_prompt": "\u65B0\u898F\u30D7\u30ED\u30F3\u30D7\u30C8\u3092\u8FFD\u52A0",
    "edit_prompt": "\u7DE8\u96C6",
    "delete_prompt": "\u524A\u9664",
    "export_prompts": "\u3059\u3079\u3066\u306E\u30D7\u30ED\u30F3\u30D7\u30C8\u3092\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
    "import_prompts": "\u30D7\u30ED\u30F3\u30D7\u30C8\u3092\u30A4\u30F3\u30DD\u30FC\u30C8",
    "export_prompts_desc": "\u3059\u3079\u3066\u306EAI\u30D7\u30ED\u30F3\u30D7\u30C8\u3092JSON\u30D5\u30A1\u30A4\u30EB\u3068\u3057\u3066\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
    "import_prompts_desc": "JSON\u30D5\u30A1\u30A4\u30EB\u304B\u3089AI\u30D7\u30ED\u30F3\u30D7\u30C8\u3092\u30A4\u30F3\u30DD\u30FC\u30C8",
    "import_success": "\u30D7\u30ED\u30F3\u30D7\u30C8\u306E\u30A4\u30F3\u30DD\u30FC\u30C8\u306B\u6210\u529F\u3057\u307E\u3057\u305F",
    "import_error": "\u30D7\u30ED\u30F3\u30D7\u30C8\u306E\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC\uFF1A\u7121\u52B9\u306A\u30D5\u30A1\u30A4\u30EB\u5F62\u5F0F\u3067\u3059",
    "export_prompt": "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
    "export_single_prompt_desc": "\u3053\u306E\u30D7\u30ED\u30F3\u30D7\u30C8\u3092JSON\u30D5\u30A1\u30A4\u30EB\u3068\u3057\u3066\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
    "show_in_clipper": "\u30AF\u30EA\u30C3\u30D1\u30FC\u306B\u8868\u793A",
    "show_in_clipper_desc": "\u30B3\u30F3\u30C6\u30F3\u30C4\u3092\u30AF\u30EA\u30C3\u30D7\u3059\u308B\u969B\u306B\u3053\u306E\u30D7\u30ED\u30F3\u30D7\u30C8\u3092\u30AF\u30EA\u30C3\u30D7\u30E2\u30FC\u30C0\u30EB\u306B\u8868\u793A",
    "hide_in_clipper": "\u30AF\u30EA\u30C3\u30D1\u30FC\u306B\u975E\u8868\u793A",
    "hide_in_clipper_desc": "\u3053\u306E\u30D7\u30ED\u30F3\u30D7\u30C8\u3092\u30AF\u30EA\u30C3\u30D7\u30E2\u30FC\u30C0\u30EB\u304B\u3089\u975E\u8868\u793A\u306B\u3059\u308B",
    "support_tab": "\u30B5\u30DD\u30FC\u30C8",
    "github_repo": "GitHub\u30EA\u30DD\u30B8\u30C8\u30EA",
    "github_repo_desc": "\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u3001\u554F\u984C\u5831\u544A\u3001\u30A2\u30C3\u30D7\u30C7\u30FC\u30C8\u306B\u3064\u3044\u3066\u306FGitHub\u30EA\u30DD\u30B8\u30C8\u30EA\u3092\u3054\u89A7\u304F\u3060\u3055\u3044",
    "open_github": "GitHub\u3092\u958B\u304F",
    "support_development": "\u958B\u767A\u3092\u30B5\u30DD\u30FC\u30C8",
    "support_development_desc": "\u3053\u306E\u30D7\u30E9\u30B0\u30A4\u30F3\u304C\u4FBF\u5229\u3060\u3068\u611F\u3058\u305F\u3089\u3001\u958B\u767A\u3092\u30B5\u30DD\u30FC\u30C8\u3057\u3066\u3044\u305F\u3060\u304F\u304B\u3001GitHub\u3067\u30B9\u30BF\u30FC\u3092\u4ED8\u3051\u3066\u3044\u305F\u3060\u3051\u308B\u3068\u5B09\u3057\u3044\u3067\u3059\uFF01",
    "buy_coffee": "\u30B3\u30FC\u30D2\u30FC\u3092\u8CB7\u3046",
    "buy_coffee_desc": "Buy Me a Coffee\u3067\u30B5\u30DD\u30FC\u30C8",
    "support_kofi": "Ko-fi\u3067\u30B5\u30DD\u30FC\u30C8",
    "support_kofi_desc": "Ko-fi\u3067\u30B5\u30DD\u30FC\u30C8",
    "home_tab": "\u30DB\u30FC\u30E0\u30BF\u30D6",
    "show_clock": "\u6642\u8A08\u3092\u8868\u793A",
    "show_recent_files": "\u6700\u8FD1\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u8868\u793A",
    "show_saved_articles": "\u4FDD\u5B58\u3055\u308C\u305F\u8A18\u4E8B\u3092\u8868\u793A",
    "replace_new_tabs": "\u65B0\u898F\u30BF\u30D6\u3092\u7F6E\u304D\u63DB\u3048\u308B",
    "replace_new_tabs_desc": "\u6709\u52B9\u306B\u3059\u308B\u3068\u3001\u65B0\u3057\u3044\u7A7A\u306E\u30BF\u30D6\u304CNetClip\u30DB\u30FC\u30E0\u30BF\u30D6\u306B\u7F6E\u304D\u63DB\u3048\u3089\u308C\u307E\u3059",
    "show_clock_desc": "\u30DB\u30FC\u30E0\u30BF\u30D6\u306B\u6642\u8A08\u3092\u8868\u793A\u3057\u307E\u3059",
    "show_recent_files_desc": "\u30DB\u30FC\u30E0\u30BF\u30D6\u306B\u6700\u8FD1\u306E\u30D5\u30A1\u30A4\u30EB\u30BB\u30AF\u30B7\u30E7\u30F3\u3092\u8868\u793A\u3057\u307E\u3059",
    "show_saved_articles_desc": "\u30DB\u30FC\u30E0\u30BF\u30D6\u306B\u4FDD\u5B58\u3055\u308C\u305F\u8A18\u4E8B\u30BB\u30AF\u30B7\u30E7\u30F3\u3092\u8868\u793A\u3057\u307E\u3059"
  }
};

// src/mediaUtils.ts
async function findFirstImageInNote(app, content) {
  try {
    const markdownMatch = content.match(/!\[(.*?)\]\((\S+?(?:\.(?:jpg|jpeg|png|gif|webp)|format=(?:jpg|jpeg|png|gif|webp))[^\s)]*)\s*(?:\s+["'][^"']*["'])?\s*\)/i);
    if (markdownMatch && markdownMatch[2]) {
      return markdownMatch[2];
    }
    const internalMatch = content.match(/!?\[\[(.*?\.(?:jpg|jpeg|png|gif|webp))(?:\|.*?)?\]\]/i);
    if (internalMatch && internalMatch[1]) {
      const file = app.metadataCache.getFirstLinkpathDest(internalMatch[1], "");
      if (file) {
        return app.vault.getResourcePath(file);
      }
    }
    return null;
  } catch (error) {
    console.error("Error finding image in note:", error);
    return null;
  }
}

// src/view/ClipperView.ts
var CLIPPER_VIEW = "clipper-view";
var ClipperHomeView = class extends import_obsidian9.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentCategory = "";
    this.icon = "newspaper";
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  getViewType() {
    return CLIPPER_VIEW;
  }
  getDisplayText() {
    return t("clipper_view");
  }
  async reloadView() {
    this.containerEl.empty();
    await this.onOpen();
  }
  async onOpen() {
    this.containerEl = this.containerEl.children[1];
    this.containerEl.empty();
    const clipperContainer = this.containerEl.createEl("div", { cls: "net_clipper_container" });
    const clipperHeader = clipperContainer.createEl("div", { cls: "net_clipper_header" });
    const rightContainer = clipperHeader.createEl("div", { cls: "net_clipper_header_right" });
    const openWeb = rightContainer.createEl("span", { cls: "netopen_Web", attr: { "aria-label": t("open_web") } });
    const openSettings = rightContainer.createEl("span", { cls: "netopen_settings", attr: { "aria-label": t("open_settings") } });
    (0, import_obsidian9.setIcon)(openWeb, "globe");
    (0, import_obsidian9.setIcon)(openSettings, "lucide-bolt");
    const searchBoxContainer = clipperContainer.createEl("div", { cls: "netclip_search_box" });
    const searchIcon = searchBoxContainer.createEl("span", { cls: "netclip_search_icon" });
    (0, import_obsidian9.setIcon)(searchIcon, "search");
    const searchInput = searchBoxContainer.createEl("input", {
      type: "text",
      cls: "netclip_search_input",
      placeholder: t("search_saved_articles")
    });
    const bottomContainer = clipperContainer.createEl("div", { cls: "netclip_bottom_container" });
    const categoryTabsContainer = bottomContainer.createEl("div", { cls: "netclip_category_tabs" });
    this.renderCategoryTabs(categoryTabsContainer);
    const sortContainer = bottomContainer.createEl("div", { cls: "netclip_sort_container" });
    const domainSortButton = sortContainer.createEl("button", {
      cls: "netclip_sort_button",
      attr: { "aria-label": t("domain_filter") }
    });
    const sortButton = sortContainer.createEl("button", {
      cls: "netclip_sort_button",
      attr: { "aria-label": t("sort_by") }
    });
    (0, import_obsidian9.setIcon)(sortButton, "arrow-up-down");
    (0, import_obsidian9.setIcon)(domainSortButton, "earth");
    searchInput.addEventListener("input", () => {
      const searchTerm = searchInput.value.toLowerCase();
      const savedContainer = this.containerEl.querySelector(".netclip_saved_container");
      this.renderSavedContent(savedContainer, searchTerm);
    });
    const clipButtonContainer = clipperHeader.createEl("div", { cls: "netclip_button_container" });
    const clipButton = clipButtonContainer.createEl("button", {
      cls: "netclip_btn",
      attr: { "aria-label": t("add_clip") }
    });
    (0, import_obsidian9.setIcon)(clipButton, "plus");
    sortButton.addEventListener("click", (event) => {
      const menu = new import_obsidian10.Menu();
      menu.addItem(
        (item) => item.setTitle(t("sort_a_z")).setIcon("arrow-up").onClick(() => this.applySort("a-z"))
      );
      menu.addItem(
        (item) => item.setTitle(t("sort_z_a")).setIcon("arrow-down").onClick(() => this.applySort("z-a"))
      );
      menu.addItem(
        (item) => item.setTitle(t("sort_newest_first")).setIcon("arrow-down").onClick(() => this.applySort("new-old"))
      );
      menu.addItem(
        (item) => item.setTitle(t("sort_oldest_first")).setIcon("arrow-up").onClick(() => this.applySort("old-new"))
      );
      menu.showAtMouseEvent(event);
    });
    domainSortButton.addEventListener("click", async (event) => {
      const menu = new import_obsidian10.Menu();
      const files = this.app.vault.getMarkdownFiles();
      const domains = /* @__PURE__ */ new Set();
      const baseFolderPath = this.settings.parentFolderPath ? `${this.settings.parentFolderPath}/${this.settings.defaultFolderName}` : this.settings.defaultFolderName;
      await Promise.all(files.map(async (file) => {
        if (file.path.startsWith(baseFolderPath)) {
          const content = await this.app.vault.cachedRead(file);
          const urlMatch = content.match(/source: "([^"]+)"/);
          if (urlMatch) {
            const domain = getDomain(urlMatch[1]);
            domains.add(domain);
          }
        }
      }));
      menu.addItem(
        (item) => item.setTitle(t("all_domains")).setIcon("dot").onClick(() => this.applyDomainFilter(""))
      );
      domains.forEach((domain) => {
        const displayName = domain.replace(".com", "");
        menu.addItem(
          (item) => item.setTitle(displayName).setIcon("dot").onClick(() => this.applyDomainFilter(domain))
        );
      });
      menu.showAtMouseEvent(event);
    });
    const SavedContentBox = clipperContainer.createEl("div", { cls: "netclip_saved_container" });
    openWeb.addEventListener("click", async () => {
      const defaultUrl = this.settings.defaultWebUrl || "https://google.com";
      const existingLeaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_WORKSPACE_WEBVIEW).find((leaf) => {
        const view = leaf.view;
        return view.url === defaultUrl;
      });
      if (existingLeaf) {
        this.app.workspace.setActiveLeaf(existingLeaf, { focus: true });
      } else {
        const leaf = this.app.workspace.getLeaf(true);
        await leaf.setViewState({
          type: VIEW_TYPE_WORKSPACE_WEBVIEW,
          state: { url: defaultUrl }
        });
        this.app.workspace.setActiveLeaf(leaf, { focus: true });
      }
    });
    openSettings.addEventListener("click", () => {
      this.app.setting.open();
      this.app.setting.openTabById(this.plugin.manifest.id);
    });
    clipButton.addEventListener("click", () => {
      new ClipModal(this.app, this.plugin).open();
    });
    await this.renderSavedContent(SavedContentBox);
  }
  async applySort(sortOrder) {
    const savedContainer = this.containerEl.querySelector(".netclip_saved_container");
    await this.renderSavedContent(savedContainer, "", sortOrder);
  }
  async applyDomainFilter(domain) {
    const savedContainer = this.containerEl.querySelector(".netclip_saved_container");
    await this.renderSavedContent(savedContainer, "", "a-z", domain);
  }
  renderCategoryTabs(tabsContainer) {
    tabsContainer.empty();
    const allTab = tabsContainer.createEl("div", {
      cls: `netclip_category_tab ${this.currentCategory === "" ? "active" : ""}`
    });
    const allTabContent = allTab.createEl("div", { cls: "netclip-category-content" });
    allTabContent.createEl("span", { text: t("all") });
    allTab.addEventListener("click", () => this.switchCategory("", tabsContainer));
    this.plugin.settings.categories.forEach((category) => {
      const tab = tabsContainer.createEl("div", {
        cls: `netclip_category_tab ${this.currentCategory === category ? "active" : ""}`
      });
      const tabContent = tab.createEl("div", { cls: "netclip-category-content" });
      if (this.plugin.settings.categoryIcons[category]) {
        const iconSpan = tabContent.createEl("span", { cls: "category-icon" });
        (0, import_obsidian9.setIcon)(iconSpan, this.plugin.settings.categoryIcons[category]);
      }
      tabContent.createEl("span", { text: category });
      tab.addEventListener("click", () => this.switchCategory(category, tabsContainer));
    });
  }
  async switchCategory(category, tabsContainer) {
    this.currentCategory = category;
    const tabs = tabsContainer.querySelectorAll(".netclip_category_tab");
    tabs.forEach((tab) => {
      tab.classList.remove("active");
      if (category === "" && tab.textContent === t("all") || tab.textContent === category) {
        tab.classList.add("active");
      }
    });
    const savedContainer = this.containerEl.querySelector(".netclip_saved_container");
    await this.renderSavedContent(savedContainer);
  }
  async renderSavedContent(container, filter = "", sortOrder = "new-old", domainFilter = "") {
    container.empty();
    const files = this.app.vault.getMarkdownFiles();
    const baseFolderPath = this.settings.parentFolderPath ? `${this.settings.parentFolderPath}/${this.settings.defaultFolderName}` : this.settings.defaultFolderName;
    const clippedFiles = files.filter((file) => {
      const isInMainFolder = file.path.startsWith(baseFolderPath);
      if (!this.currentCategory) {
        return isInMainFolder;
      }
      return file.path.startsWith(`${baseFolderPath}/${this.currentCategory}`);
    });
    let filteredFiles = filter ? clippedFiles.filter((file) => file.basename.toLowerCase().includes(filter)) : clippedFiles;
    if (domainFilter) {
      filteredFiles = (await Promise.all(filteredFiles.map(async (file) => {
        const content = await this.app.vault.cachedRead(file);
        const urlMatch = content.match(/source: "([^"]+)"/);
        if (urlMatch) {
          const domain = getDomain(urlMatch[1]);
          return domain === domainFilter ? file : null;
        }
        return null;
      }))).filter(Boolean);
    }
    const sortedFiles = filteredFiles.sort((a, b) => {
      switch (sortOrder) {
        case "a-z":
          return a.basename.localeCompare(b.basename);
        case "z-a":
          return b.basename.localeCompare(a.basename);
        case "new-old":
          return b.stat.mtime - a.stat.mtime;
        case "old-new":
          return a.stat.mtime - b.stat.mtime;
        default:
          return 0;
      }
    });
    if (sortedFiles.length === 0) {
      const emptyContainer = container.createEl("div", { cls: "empty_box" });
      const emptyIcon = emptyContainer.createEl("span", { cls: "empty_icon" });
      (0, import_obsidian9.setIcon)(emptyIcon, "lucide-book-open");
      emptyContainer.createEl("p", { text: t("no_matching_articles") });
      return;
    }
    for (const file of sortedFiles) {
      const content = await this.app.vault.cachedRead(file);
      const clippedEl = container.createEl("div", { cls: "netClip_card" });
      if (this.settings.cardDisplay.showThumbnail) {
        const frontmatterMatch = content.match(/^---[\s\S]*?thumbnail: "([^"]+)"[\s\S]*?---/);
        let thumbnailUrl = frontmatterMatch ? frontmatterMatch[1] : null;
        if (!thumbnailUrl) {
          const thumbnailMatch = content.match(/!\[Thumbnail\]\((.+)\)/);
          thumbnailUrl = thumbnailMatch ? thumbnailMatch[1] : null;
        }
        if (!thumbnailUrl) {
          thumbnailUrl = await findFirstImageInNote(this.app, content);
        }
        clippedEl.createEl("img", {
          attr: {
            src: thumbnailUrl || DEFAULT_IMAGE,
            loading: "lazy"
          }
        });
      }
      const contentContainer = clippedEl.createEl("div", { cls: "netclip_card_content" });
      const topContainer = contentContainer.createEl("div", { cls: "netclip_card_top" });
      const clippedTitle = topContainer.createEl("h6", { text: file.basename });
      clippedTitle.addEventListener("click", () => {
        this.openArticle(file);
      });
      if (this.settings.cardDisplay.showDescription) {
        const descriptionMatch = content.match(/desc:\s*(?:"([^"]+)"|([^\n]+))/);
        if (descriptionMatch) {
          topContainer.createEl("p", {
            cls: "netclip_card_description",
            text: descriptionMatch[1] || descriptionMatch[2]
          });
        }
      }
      const metaContainer = topContainer.createEl("div", { cls: "netclip_card_meta" });
      if (this.settings.cardDisplay.showAuthor) {
        const authorMatch = content.match(/author:\s*(?:"([^"]+)"|([^\n]+))/);
        if (authorMatch) {
          metaContainer.createEl("span", {
            cls: "netclip_card_author",
            text: authorMatch[1] || authorMatch[2]
          });
        }
      }
      if (this.settings.cardDisplay.showDate) {
        const creationDate = new Date(file.stat.ctime);
        const formattedDate = creationDate.toLocaleDateString(void 0, {
          year: "numeric",
          month: "short",
          day: "numeric"
        });
        metaContainer.createEl("span", {
          cls: "netclip_card_date",
          text: formattedDate
        });
      }
      const bottomContent = contentContainer.createEl("div", { cls: "netclip_card_bottom" });
      const urlMatch = content.match(/source: "([^"]+)"/);
      if (this.settings.cardDisplay.showDomain && urlMatch) {
        const articleUrl = urlMatch[1];
        const domainName = getDomain(articleUrl);
        bottomContent.createEl("a", {
          cls: "domain",
          href: articleUrl,
          text: domainName
        });
      }
      this.createMenuButton(bottomContent, file, urlMatch == null ? void 0 : urlMatch[1]);
      container.appendChild(clippedEl);
    }
  }
  createMenuButton(bottomContent, file, url) {
    const menuButton = bottomContent.createEl("span", { cls: "menu-button" });
    (0, import_obsidian9.setIcon)(menuButton, "more-vertical");
    menuButton.addEventListener("click", (event) => {
      event.preventDefault();
      event.stopPropagation();
      const contextMenu = new ClipperContextMenu(
        this.app,
        file,
        this.showDeleteConfirmation.bind(this),
        this.openArticle.bind(this),
        url
      );
      contextMenu.show(menuButton);
    });
  }
  showDeleteConfirmation(file) {
    const modal = new DeleteConfirmationModal(
      this.app,
      file,
      async () => {
        await this.app.fileManager.trashFile(file);
        const savedContainer = this.containerEl.querySelector(".netclip_saved_container");
        await this.renderSavedContent(savedContainer);
      }
    );
    modal.open();
  }
  openArticle(file) {
    const openLeaves = this.app.workspace.getLeavesOfType("markdown");
    const targetLeaf = openLeaves.find((leaf) => {
      var _a;
      const viewState = leaf.getViewState();
      return viewState.type === "markdown" && ((_a = viewState.state) == null ? void 0 : _a.file) === file.path;
    });
    if (targetLeaf) {
      this.app.workspace.revealLeaf(targetLeaf);
    } else {
      this.app.workspace.openLinkText(file.path, "", true);
    }
  }
};

// src/Extractors/helper.ts
var ProcessNodeHelper = class {
  constructor(plugin) {
    this.recentLinks = /* @__PURE__ */ new Set();
    this.seenImages = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  resetProcessingFlags() {
    this.seenImages.clear();
    this.recentLinks.clear();
  }
  processNode(node, baseUrl) {
    if (node.nodeType === Node.TEXT_NODE) {
      return (node.textContent || "").trim();
    }
    if (!(node instanceof HTMLElement)) {
      return "";
    }
    const element = node;
    return this.processElement(element, baseUrl);
  }
  processElement(element, baseUrl) {
    const tagProcessors = {
      BLOCKQUOTE: (el) => this.processBlockquote(el, baseUrl),
      A: (el) => this.processAnchor(el, baseUrl),
      STRONG: (el) => this.processWrappedContent(el, baseUrl, "**"),
      EM: (el) => this.processWrappedContent(el, baseUrl, "*"),
      H1: (el) => this.processHeading(el, baseUrl, 1),
      H2: (el) => this.processHeading(el, baseUrl, 2),
      H3: (el) => this.processHeading(el, baseUrl, 3),
      H4: (el) => this.processHeading(el, baseUrl, 4),
      H5: (el) => this.processHeading(el, baseUrl, 5),
      H6: (el) => this.processHeading(el, baseUrl, 6),
      TABLE: (el) => this.processTable(el, baseUrl),
      UL: (el) => this.processList(el, baseUrl, "ul"),
      OL: (el) => this.processList(el, baseUrl, "ol"),
      P: (el) => this.processParagraph(el, baseUrl),
      BR: () => "\n",
      HR: () => "---\n\n",
      IMG: (el) => this.processImage(el, baseUrl),
      IFRAME: (el) => this.processIframe(el),
      VIDEO: (el) => this.processVideo(el),
      CODE: (el) => this.processCode(el),
      PRE: (el) => this.processPre(el, baseUrl)
    };
    const processor = tagProcessors[element.tagName];
    if (processor) {
      return processor(element);
    }
    return Array.from(element.childNodes).map((child) => this.processNode(child, baseUrl)).join("");
  }
  processBlockquote(element, baseUrl) {
    const content = Array.from(element.childNodes).map((child) => this.processNode(child, baseUrl)).join("").trim();
    return content ? `> ${content.replace(/\n/g, "\n> ")}

` : "";
  }
  processAnchor(element, baseUrl) {
    var _a, _b, _c;
    const href = element.getAttribute("href");
    const text = ((_a = element.textContent) == null ? void 0 : _a.trim()) || "";
    if (!href || !text) return text;
    const absoluteLink = this.resolveUrl(baseUrl, href);
    const linkKey = `${text}:${absoluteLink}`;
    if (this.recentLinks.has(linkKey)) return text;
    this.recentLinks.add(linkKey);
    if (this.recentLinks.size > 10) {
      const oldestLink = this.recentLinks.values().next().value;
      this.recentLinks.delete(oldestLink);
    }
    const prefixSpace = this.shouldAddSpace(element.previousSibling) || "";
    const suffixSpace = this.shouldAddSpace(element.nextSibling) || "";
    const needsPrefixSpace = prefixSpace === "" && (((_b = element.previousSibling) == null ? void 0 : _b.nodeType) === Node.TEXT_NODE || element.previousSibling instanceof HTMLElement);
    const needsSuffixSpace = suffixSpace === "" && (((_c = element.nextSibling) == null ? void 0 : _c.nodeType) === Node.TEXT_NODE || element.nextSibling instanceof HTMLElement);
    return `${needsPrefixSpace ? " " : ""}[${text}](${absoluteLink})${needsSuffixSpace ? " " : ""}`;
  }
  processWrappedContent(element, baseUrl, wrapper) {
    const content = Array.from(element.childNodes).map((child) => this.processNode(child, baseUrl)).join("");
    return `${wrapper}${content}${wrapper}`;
  }
  processHeading(element, baseUrl, level) {
    const content = Array.from(element.childNodes).map((child) => this.processNode(child, baseUrl)).join("");
    return `${"#".repeat(level)} ${content}

`;
  }
  processTable(table, baseUrl) {
    let content = "\n";
    const rows = table.rows;
    const columnCount = Math.max(...Array.from(rows).map((row) => row.cells.length));
    if (rows.length > 0) {
      const headerRow = rows[0];
      content += "|" + Array.from(headerRow.cells).map((cell) => this.processNode(cell, baseUrl).replace(/\|/g, "\\|").trim()).join("|") + "|\n";
      content += "|" + Array(columnCount).fill("---").join("|") + "|\n";
    }
    for (let i = 1; i < rows.length; i++) {
      content += "|" + Array.from(rows[i].cells).map((cell) => this.processNode(cell, baseUrl).replace(/\|/g, "\\|").trim()).join("|") + "|\n";
    }
    return content + "\n";
  }
  processList(element, baseUrl, type) {
    const listItems = Array.from(element.childNodes).filter((child) => child.nodeName === "LI").map((child, index) => {
      const content = this.processNode(child, baseUrl).trim();
      return type === "ul" ? `- ${content}` : `${index + 1}. ${content}`;
    });
    return listItems.join("\n") + "\n\n";
  }
  processParagraph(element, baseUrl) {
    const content = Array.from(element.childNodes).map((child) => this.processNode(child, baseUrl)).join("");
    return `${content}

`;
  }
  resolveUrl(baseUrl, href) {
    try {
      return new URL(href, baseUrl).toString();
    } catch (e) {
      return href;
    }
  }
  shouldAddSpace(sibling) {
    if (!sibling) return "";
    if (sibling.nodeType === Node.TEXT_NODE) {
      const text = sibling.textContent || "";
      return /\S$/.test(text) ? " " : "";
    }
    if (sibling instanceof HTMLElement) {
      const blockElements = ["P", "DIV", "BR", "HR", "H1", "H2", "H3", "H4", "H5", "H6"];
      return blockElements.includes(sibling.tagName) ? " " : "";
    }
    return "";
  }
  processImage(element, baseUrl) {
    const crossOrigin = element.hasAttribute("crossorigin") ? element.getAttribute("crossorigin") : "anonymous";
    const dataSrcSet = element.getAttribute("data-lazy-srcset") || element.getAttribute("data-srcset");
    let src = "";
    if (dataSrcSet) {
      const urls = dataSrcSet.split(",").map((entry) => {
        const [url, size] = entry.trim().split(" ");
        return { url: this.resolveUrl(baseUrl, url), size };
      });
      const httpsUrl = urls.find((u) => u.url.startsWith("https://"));
      src = (httpsUrl == null ? void 0 : httpsUrl.url) || "";
    }
    if (!src) {
      src = this.resolveUrl(
        baseUrl,
        element.getAttribute("data-src") || element.getAttribute("src") || ""
      );
    }
    const alt = element.getAttribute("alt") || "";
    if (!src || this.seenImages.has(src)) return "";
    this.seenImages.add(src);
    return `![${alt}](${src}?crossorigin=${encodeURIComponent(crossOrigin)})`;
  }
  processIframe(element) {
    const src = element.getAttribute("src");
    return src ? `[Embedded content](${src})

` : "";
  }
  processVideo(element) {
    const src = element.getAttribute("src");
    return src ? `[Video content](${src})

` : "";
  }
  processCode(element) {
    const content = element.textContent || "";
    return `\`${content.trim()}\``;
  }
  processPre(element, baseUrl) {
    const content = Array.from(element.childNodes).map((child) => this.processNode(child, baseUrl)).join("");
    return `\`\`\`
${content.trim()}
\`\`\`

`;
  }
};

// src/Extractors/extractor.ts
var import_readability = __toESM(require_readability());

// src/Extractors/constants.ts
var CONSTANTS = {
  MAX_DESCRIPTION_LENGTH: 200,
  CURRENCY_MAP: {
    "$": "USD",
    "\xA3": "GBP",
    "\u20AC": "EUR",
    "\xA5": "JPY",
    USD: "USD",
    EUR: "EUR",
    GBP: "GBP",
    JPY: "JPY"
  },
  SELECTORS: {
    MAIN_CONTENT: [
      "main",
      "article",
      ".main-content",
      "#main-content",
      ".entry-content",
      "#productDescription",
      "#feature-bullets",
      ".markdown",
      '[class*="blog"]',
      "#centerCol",
      ".a-section.a-spacing-none",
      ".Blog"
    ],
    CLEANUP: [
      "script",
      "style",
      "svg",
      "nav",
      "footer",
      "header",
      "aside",
      '[class*="footer"]',
      '[class*="nav"]',
      '[class*="sidebar"]',
      ".ad-container",
      ".advertisement",
      ".cookie-consent",
      ".menu",
      ".tags",
      '[class*="popup"]',
      '[class*="related"]',
      ".related"
    ],
    PRICE: [".price", ".current-price", ".priceToPay", ".a-price", "#priceblock_ourprice"]
  }
};

// src/Extractors/utils.ts
var DOMHelper = class {
  static setContentSafely(element, content) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(content, "text/html");
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
    Array.from(doc.body.childNodes).forEach((node) => {
      element.appendChild(document.importNode(node, true));
    });
  }
  static resolveUrl(url, base) {
    if (!url || url.startsWith("data:") || url.startsWith("blob:")) return url;
    try {
      return new URL(url, base).toString();
    } catch (e) {
      return url;
    }
  }
  static extractFromSelectors(doc, selectors) {
    return selectors.reduce((acc, selector) => {
      var _a, _b;
      return acc || ((_b = (_a = doc.querySelector(selector)) == null ? void 0 : _a.textContent) == null ? void 0 : _b.trim()) || null;
    }, null);
  }
};
var TextHelper = class {
  static cleanText(text, maxLength) {
    return text.replace(/[\r\n\t]+/g, " ").replace(/\s+/g, " ").replace(/[<>]/g, "").trim().substring(0, maxLength).replace(/\w+$/, "").trim() + (text.length > maxLength ? "..." : "");
  }
  static cleanAuthor(author) {
    return author.replace(/^(by|written by|posted by|authored by)\s+/i, "").replace(/\s*\|\s*\d+.*$/, "").replace(/\s*\(\d+.*\)/, "").replace(/\s*[,\|]\s*(staff\s+writer|contributor|guest\s+author|editor).*/i, "").trim();
  }
  static cleanBrand(brand) {
    return brand.replace(/^(brand|by|visit|store|shop)[:|\s]+/i, "").replace(/\s*(›|»|»|·|\||\-|—)\s*.*/i, "").trim();
  }
  static normalizePrice(price) {
    const match = price.match(/\d+([.,]\d{2})?/);
    return match ? match[0].replace(/,(\d{2})$/, ".$1").replace(/^(\d+),(\d{2,})$/, "$1.$2") : "0.00";
  }
  static extractCurrency(text) {
    var _a;
    const symbol = (_a = text.match(/[\$€£]|USD|EUR|GBP/)) == null ? void 0 : _a[0];
    return symbol ? CONSTANTS.CURRENCY_MAP[symbol] : void 0;
  }
};

// src/Extractors/extractor.ts
var ContentExtractors = class {
  constructor(plugin) {
    this.mediaContents = /* @__PURE__ */ new Set();
    this.plugin = plugin;
    this.processNodeHelper = new ProcessNodeHelper(plugin);
  }
  extractMainContent(doc, baseUrl) {
    this.processNodeHelper.resetProcessingFlags();
    this.mediaContents.clear();
    const docClone = doc.cloneNode(true);
    docClone.querySelectorAll('img[src*=".gif"], img[data-src*=".gif"]').forEach((gif) => gif.classList.add("gif"));
    const article = new import_readability.Readability(docClone, {
      charThreshold: 20,
      classesToPreserve: ["markdown", "highlight", "code", "gif"],
      nbTopCandidates: 5,
      maxElemsToParse: 0,
      keepClasses: true
    }).parse();
    if (!article) return this.fallbackExtraction(doc, baseUrl);
    const container = document.createElement("div");
    DOMHelper.setContentSafely(container, article.content || "");
    const mediaElements = this.processMediaElements(container, baseUrl);
    return this.buildMetadata(article) + this.processNodeHelper.processNode(container, baseUrl).replace(/\n{3,}/g, "\n\n").trim() + mediaElements;
  }
  processMediaElements(container, baseUrl) {
    const mediaElements = [];
    container.querySelectorAll('img[src*=".gif"], img[data-src*=".gif"], .gif').forEach((gif) => {
      const url = DOMHelper.resolveUrl(gif.getAttribute("src") || gif.getAttribute("data-src") || "", baseUrl);
      const alt = gif.getAttribute("alt") || "GIF";
      if (url && !this.mediaContents.has(url)) {
        this.mediaContents.add(url);
        mediaElements.push({ type: "gif", url, alt });
      }
    });
    return mediaElements.map((media) => `
![${media.alt}](${media.url})
`).join("");
  }
  extractThumbnail(doc) {
    var _a, _b;
    const ogImage = doc.querySelector('meta[property="og:image"]');
    if (ogImage) {
      const content = ogImage.getAttribute("content");
      return content ? `${content}?crossorigin=anonymous` : "";
    }
    const imgElements = doc.querySelectorAll("img[data-lazy-srcset], img[data-srcset], img[data-src]");
    for (const img of Array.from(imgElements)) {
      const srcset = img.getAttribute("data-lazy-srcset") || img.getAttribute("data-srcset");
      if (srcset) {
        const urls = srcset.split(",").map((entry) => entry.trim().split(" ")[0]);
        const httpsUrl = urls.find((url) => url.startsWith("https://"));
        if (httpsUrl) return httpsUrl;
      }
      const dataSrc = img.getAttribute("data-src");
      if (dataSrc == null ? void 0 : dataSrc.startsWith("https://")) return dataSrc;
    }
    const imgSrc = (_a = doc.querySelector('img[src^="https://"]')) == null ? void 0 : _a.getAttribute("src");
    if (imgSrc) return imgSrc;
    return ((_b = doc.querySelector(".a-dynamic-image")) == null ? void 0 : _b.getAttribute("src")) || "";
  }
  extractDescription(doc) {
    const jsonLd = this.parseJsonLd(doc);
    const sources = [
      () => {
        var _a;
        return jsonLd.description || ((_a = jsonLd.articleBody) == null ? void 0 : _a.substring(0, CONSTANTS.MAX_DESCRIPTION_LENGTH));
      },
      () => {
        var _a;
        return (_a = doc.querySelector('meta[name="description"]')) == null ? void 0 : _a.getAttribute("content");
      },
      () => {
        var _a;
        return (_a = doc.querySelector('meta[property="og:description"]')) == null ? void 0 : _a.getAttribute("content");
      },
      () => {
        var _a;
        return (_a = doc.querySelector('meta[name="twitter:description"]')) == null ? void 0 : _a.getAttribute("content");
      },
      () => DOMHelper.extractFromSelectors(doc, [
        '[itemprop="description"]',
        ".product-description",
        "#productDescription",
        ".description",
        "#description"
      ])
    ];
    const description = sources.reduce((acc, source) => acc || source(), null);
    return description ? TextHelper.cleanText(description, CONSTANTS.MAX_DESCRIPTION_LENGTH) : null;
  }
  extractPublishTime(doc) {
    const jsonLd = this.parseJsonLd(doc);
    const sources = [
      () => jsonLd.datePublished || jsonLd.dateCreated || jsonLd.dateModified,
      () => {
        var _a;
        return (_a = doc.querySelector('meta[property="article:published_time"]')) == null ? void 0 : _a.getAttribute("content");
      },
      () => {
        var _a;
        return (_a = doc.querySelector('meta[property="og:published_time"]')) == null ? void 0 : _a.getAttribute("content");
      },
      () => {
        var _a;
        return (_a = doc.querySelector("time[datetime]")) == null ? void 0 : _a.getAttribute("datetime");
      },
      () => DOMHelper.extractFromSelectors(doc, [
        '[itemprop="datePublished"]',
        ".published-date",
        ".post-date",
        ".article-date"
      ])
    ];
    const date = sources.reduce((acc, source) => acc || source(), null);
    return date ? new Date(date).toISOString() : null;
  }
  extractAuthor(doc) {
    const jsonLd = this.parseJsonLd(doc);
    const sources = [
      () => {
        const article = new import_readability.Readability(doc.cloneNode(true)).parse();
        return article == null ? void 0 : article.byline;
      },
      () => {
        var _a;
        return ((_a = jsonLd.author) == null ? void 0 : _a.name) || (typeof jsonLd.author === "string" ? jsonLd.author : null);
      },
      () => {
        var _a;
        return (_a = doc.querySelector('meta[name="author"]')) == null ? void 0 : _a.getAttribute("content");
      },
      () => DOMHelper.extractFromSelectors(doc, [
        '[itemProp="author"] [itemProp="name"]',
        '[itemProp="author"]',
        ".author-name",
        ".author",
        '[class*="author"]'
      ])
    ];
    const author = sources.reduce((acc, source) => acc || source(), null);
    return author ? TextHelper.cleanAuthor(author) : null;
  }
  extractPrice(doc) {
    const prices = this.extractPriceInfo(doc);
    return prices.length ? prices.map(
      (price) => price.currency ? `${price.currency === "USD" ? "$" : price.currency === "GBP" ? "\xA3" : "\u20AC"}${price.amount}` : price.amount
    ).join(", ") : null;
  }
  extractPriceInfo(doc) {
    var _a;
    const jsonLd = this.parseJsonLd(doc);
    const prices = [];
    if ((_a = jsonLd.offers) == null ? void 0 : _a.price) {
      prices.push({
        amount: jsonLd.offers.price.toString(),
        currency: jsonLd.offers.priceCurrency
      });
    }
    CONSTANTS.SELECTORS.PRICE.forEach((selector) => {
      var _a2, _b;
      const priceText = (_b = (_a2 = doc.querySelector(selector)) == null ? void 0 : _a2.textContent) == null ? void 0 : _b.trim();
      if (priceText == null ? void 0 : priceText.match(/(?:\$|€|£|USD|EUR|GBP)?\s*\d+([.,]\d{2})?/)) {
        prices.push({
          amount: TextHelper.normalizePrice(priceText),
          currency: TextHelper.extractCurrency(priceText)
        });
      }
    });
    return Array.from(new Map(
      prices.map((price) => [`${price.currency || ""}${price.amount}`, price])
    ).values());
  }
  extractBrand(doc) {
    const jsonLd = this.parseJsonLd(doc);
    const sources = [
      () => {
        var _a, _b;
        return ((_a = jsonLd.brand) == null ? void 0 : _a.name) || ((_b = jsonLd.manufacturer) == null ? void 0 : _b.name);
      },
      () => {
        var _a;
        return (_a = doc.querySelector('meta[property="og:brand"]')) == null ? void 0 : _a.getAttribute("content");
      },
      () => {
        var _a;
        return (_a = doc.querySelector('meta[property="product:brand"]')) == null ? void 0 : _a.getAttribute("content");
      },
      () => DOMHelper.extractFromSelectors(doc, [
        "#brand",
        ".brand",
        '[itemprop="brand"]',
        ".product-brand",
        "#bylineInfo"
      ])
    ];
    const brand = sources.reduce((acc, source) => acc || source(), null);
    return brand ? TextHelper.cleanBrand(brand) : null;
  }
  extractRating(doc) {
    var _a, _b;
    const ratingElement = doc.querySelector([
      "#acrPopover",
      'meta[itemprop="rating"]',
      ".average-rating",
      ".star-rating",
      '[class*="rating"]'
    ].join(","));
    let rating = (_a = ratingElement == null ? void 0 : ratingElement.textContent) == null ? void 0 : _a.trim();
    if (!rating) {
      const stars = (_b = Array.from(doc.querySelectorAll("span, div")).find((el) => {
        var _a2;
        return (_a2 = el.textContent) == null ? void 0 : _a2.trim().match(/^★+$/);
      })) == null ? void 0 : _b.textContent;
      if (stars) {
        rating = `${stars.length} out of 5 stars`;
      }
    }
    if (rating) {
      const numericMatch = rating.match(/(\d+(\.\d+)?)\s*out\s*of\s*5/i);
      if (numericMatch) {
        const value = parseFloat(numericMatch[1]);
        const stars = "\u2605".repeat(Math.round(value)) + "\u2606".repeat(5 - Math.round(value));
        return `${value} out of 5 stars (${stars})`;
      }
      const starMatch = rating.match(/★+/);
      if (starMatch) {
        const value = starMatch[0].length;
        const stars = "\u2605".repeat(value) + "\u2606".repeat(5 - value);
        return `${value} out of 5 stars (${stars})`;
      }
    }
    return null;
  }
  buildMetadata(article) {
    return [
      article.title ? `# ${article.title}

` : "",
      article.byline ? `*By ${article.byline}*

` : "",
      article.excerpt ? `> ${article.excerpt}

` : ""
    ].join("");
  }
  fallbackExtraction(doc, baseUrl) {
    const mainContent = CONSTANTS.SELECTORS.MAIN_CONTENT.reduce((acc, selector) => acc || doc.querySelector(selector), doc.body);
    this.cleanupElements(mainContent);
    const mediaElements = this.processMediaElements(mainContent, baseUrl);
    return this.processNodeHelper.processNode(mainContent, baseUrl).replace(/\n{3,}/g, "\n\n").trim() + mediaElements;
  }
  cleanupElements(element) {
    const removeSelectors = CONSTANTS.SELECTORS.CLEANUP.join(",");
    element.querySelectorAll(removeSelectors).forEach((el) => {
      if (!el.matches('img[src*=".gif"], .gif') && !el.querySelector('img[src*=".gif"], .gif')) {
        el.remove();
      }
    });
  }
  parseJsonLd(doc) {
    var _a;
    try {
      return JSON.parse(((_a = doc.querySelector('script[type="application/ld+json"]')) == null ? void 0 : _a.textContent) || "{}");
    } catch (e) {
      return {};
    }
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  viewPosition: "right",
  defaultFolderName: "NetClip",
  parentFolderPath: "",
  defaultWebUrl: "https://google.com",
  searchEngine: "google",
  categories: [],
  categoryIcons: {},
  enableCorsProxy: false,
  adBlock: {
    enabled: true
  },
  privateMode: false,
  geminiApiKey: "",
  enableAI: false,
  prompts: [
    {
      name: "Translate Content",
      prompt: "Translate the following ${article} to ${target_lang}",
      enabled: false,
      variables: {
        "target_lang": ["Japanese", "English", "Spanish", "French", "German", "Chinese"]
      }
    },
    {
      name: "Summarize Content",
      prompt: "Summarize ${article} in ${style} style. Keep the summary ${length}.",
      enabled: false,
      variables: {
        "style": ["concise", "detailed", "bullet points", "academic"],
        "length": ["short (2-3 sentences)", "medium (1 paragraph)", "long (2-3 paragraphs)"]
      }
    },
    {
      name: "Format as Note",
      prompt: "Convert ${article} into a structured note with headings, bullet points, and key takeaways. Use ${format} formatting style.",
      enabled: false,
      variables: {
        "format": ["Academic", "Meeting Notes", "Study Notes"]
      }
    }
  ],
  defaultSaveLocations: {
    defaultLocation: "",
    domainMappings: {}
  },
  cardDisplay: {
    showDescription: true,
    showAuthor: true,
    showDate: true,
    showDomain: true,
    showThumbnail: true
  },
  replaceTabHome: false,
  shortcuts: [],
  showClock: true,
  homeTab: {
    showRecentFiles: true,
    showSavedArticles: true,
    backgroundImage: "",
    backgroundBlur: 0,
    textColor: "#ffffff",
    textBrightness: 100
  },
  keepOriginalContent: false
};

// node_modules/@google/generative-ai/dist/index.mjs
var SchemaType;
(function(SchemaType2) {
  SchemaType2["STRING"] = "string";
  SchemaType2["NUMBER"] = "number";
  SchemaType2["INTEGER"] = "integer";
  SchemaType2["BOOLEAN"] = "boolean";
  SchemaType2["ARRAY"] = "array";
  SchemaType2["OBJECT"] = "object";
})(SchemaType || (SchemaType = {}));
var ExecutableCodeLanguage;
(function(ExecutableCodeLanguage2) {
  ExecutableCodeLanguage2["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
  ExecutableCodeLanguage2["PYTHON"] = "python";
})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));
var Outcome;
(function(Outcome2) {
  Outcome2["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
  Outcome2["OUTCOME_OK"] = "outcome_ok";
  Outcome2["OUTCOME_FAILED"] = "outcome_failed";
  Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
})(Outcome || (Outcome = {}));
var POSSIBLE_ROLES = ["user", "model", "function", "system"];
var HarmCategory;
(function(HarmCategory2) {
  HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
  HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
  HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
})(HarmCategory || (HarmCategory = {}));
var HarmBlockThreshold;
(function(HarmBlockThreshold2) {
  HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
})(HarmBlockThreshold || (HarmBlockThreshold = {}));
var HarmProbability;
(function(HarmProbability2) {
  HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
  HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
  HarmProbability2["LOW"] = "LOW";
  HarmProbability2["MEDIUM"] = "MEDIUM";
  HarmProbability2["HIGH"] = "HIGH";
})(HarmProbability || (HarmProbability = {}));
var BlockReason;
(function(BlockReason2) {
  BlockReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
  BlockReason2["SAFETY"] = "SAFETY";
  BlockReason2["OTHER"] = "OTHER";
})(BlockReason || (BlockReason = {}));
var FinishReason;
(function(FinishReason2) {
  FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
  FinishReason2["STOP"] = "STOP";
  FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
  FinishReason2["SAFETY"] = "SAFETY";
  FinishReason2["RECITATION"] = "RECITATION";
  FinishReason2["LANGUAGE"] = "LANGUAGE";
  FinishReason2["BLOCKLIST"] = "BLOCKLIST";
  FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  FinishReason2["SPII"] = "SPII";
  FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
  FinishReason2["OTHER"] = "OTHER";
})(FinishReason || (FinishReason = {}));
var TaskType;
(function(TaskType2) {
  TaskType2["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
  TaskType2["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
  TaskType2["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
  TaskType2["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
  TaskType2["CLASSIFICATION"] = "CLASSIFICATION";
  TaskType2["CLUSTERING"] = "CLUSTERING";
})(TaskType || (TaskType = {}));
var FunctionCallingMode;
(function(FunctionCallingMode2) {
  FunctionCallingMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  FunctionCallingMode2["AUTO"] = "AUTO";
  FunctionCallingMode2["ANY"] = "ANY";
  FunctionCallingMode2["NONE"] = "NONE";
})(FunctionCallingMode || (FunctionCallingMode = {}));
var DynamicRetrievalMode;
(function(DynamicRetrievalMode2) {
  DynamicRetrievalMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  DynamicRetrievalMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(DynamicRetrievalMode || (DynamicRetrievalMode = {}));
var GoogleGenerativeAIError = class extends Error {
  constructor(message) {
    super(`[GoogleGenerativeAI Error]: ${message}`);
  }
};
var GoogleGenerativeAIResponseError = class extends GoogleGenerativeAIError {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
var GoogleGenerativeAIFetchError = class extends GoogleGenerativeAIError {
  constructor(message, status, statusText, errorDetails) {
    super(message);
    this.status = status;
    this.statusText = statusText;
    this.errorDetails = errorDetails;
  }
};
var GoogleGenerativeAIRequestInputError = class extends GoogleGenerativeAIError {
};
var GoogleGenerativeAIAbortError = class extends GoogleGenerativeAIError {
};
var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
var DEFAULT_API_VERSION = "v1beta";
var PACKAGE_VERSION = "0.24.0";
var PACKAGE_LOG_HEADER = "genai-js";
var Task;
(function(Task2) {
  Task2["GENERATE_CONTENT"] = "generateContent";
  Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
  Task2["COUNT_TOKENS"] = "countTokens";
  Task2["EMBED_CONTENT"] = "embedContent";
  Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
})(Task || (Task = {}));
var RequestUrl = class {
  constructor(model, task, apiKey, stream, requestOptions) {
    this.model = model;
    this.task = task;
    this.apiKey = apiKey;
    this.stream = stream;
    this.requestOptions = requestOptions;
  }
  toString() {
    var _a, _b;
    const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;
    const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
    let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
    if (this.stream) {
      url += "?alt=sse";
    }
    return url;
  }
};
function getClientHeaders(requestOptions) {
  const clientHeaders = [];
  if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
    clientHeaders.push(requestOptions.apiClient);
  }
  clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
  return clientHeaders.join(" ");
}
async function getHeaders(url) {
  var _a;
  const headers = new Headers();
  headers.append("Content-Type", "application/json");
  headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
  headers.append("x-goog-api-key", url.apiKey);
  let customHeaders = (_a = url.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders;
  if (customHeaders) {
    if (!(customHeaders instanceof Headers)) {
      try {
        customHeaders = new Headers(customHeaders);
      } catch (e) {
        throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);
      }
    }
    for (const [headerName, headerValue] of customHeaders.entries()) {
      if (headerName === "x-goog-api-key") {
        throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
      } else if (headerName === "x-goog-api-client") {
        throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
      }
      headers.append(headerName, headerValue);
    }
  }
  return headers;
}
async function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {
  const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
  return {
    url: url.toString(),
    fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body })
  };
}
async function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, fetchFn = fetch) {
  const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);
  return makeRequest(url, fetchOptions, fetchFn);
}
async function makeRequest(url, fetchOptions, fetchFn = fetch) {
  let response;
  try {
    response = await fetchFn(url, fetchOptions);
  } catch (e) {
    handleResponseError(e, url);
  }
  if (!response.ok) {
    await handleResponseNotOk(response, url);
  }
  return response;
}
function handleResponseError(e, url) {
  let err = e;
  if (err.name === "AbortError") {
    err = new GoogleGenerativeAIAbortError(`Request aborted when fetching ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  } else if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {
    err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  }
  throw err;
}
async function handleResponseNotOk(response, url) {
  let message = "";
  let errorDetails;
  try {
    const json = await response.json();
    message = json.error.message;
    if (json.error.details) {
      message += ` ${JSON.stringify(json.error.details)}`;
      errorDetails = json.error.details;
    }
  } catch (e) {
  }
  throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
}
function buildFetchOptions(requestOptions) {
  const fetchOptions = {};
  if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== void 0 || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
    const controller = new AbortController();
    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
      setTimeout(() => controller.abort(), requestOptions.timeout);
    }
    if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {
      requestOptions.signal.addEventListener("abort", () => {
        controller.abort();
      });
    }
    fetchOptions.signal = controller.signal;
  }
  return fetchOptions;
}
function addHelpers(response) {
  response.text = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getText(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return "";
  };
  response.functionCall = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      console.warn(`response.functionCall() is deprecated. Use response.functionCalls() instead.`);
      return getFunctionCalls(response)[0];
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return void 0;
  };
  response.functionCalls = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getFunctionCalls(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return void 0;
  };
  return response;
}
function getText(response) {
  var _a, _b, _c, _d;
  const textStrings = [];
  if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
      if (part.text) {
        textStrings.push(part.text);
      }
      if (part.executableCode) {
        textStrings.push("\n```" + part.executableCode.language + "\n" + part.executableCode.code + "\n```\n");
      }
      if (part.codeExecutionResult) {
        textStrings.push("\n```\n" + part.codeExecutionResult.output + "\n```\n");
      }
    }
  }
  if (textStrings.length > 0) {
    return textStrings.join("");
  } else {
    return "";
  }
}
function getFunctionCalls(response) {
  var _a, _b, _c, _d;
  const functionCalls = [];
  if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
      if (part.functionCall) {
        functionCalls.push(part.functionCall);
      }
    }
  }
  if (functionCalls.length > 0) {
    return functionCalls;
  } else {
    return void 0;
  }
}
var badFinishReasons = [
  FinishReason.RECITATION,
  FinishReason.SAFETY,
  FinishReason.LANGUAGE
];
function hadBadFinishReason(candidate) {
  return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason);
}
function formatBlockErrorMessage(response) {
  var _a, _b, _c;
  let message = "";
  if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {
    message += "Response was blocked";
    if ((_a = response.promptFeedback) === null || _a === void 0 ? void 0 : _a.blockReason) {
      message += ` due to ${response.promptFeedback.blockReason}`;
    }
    if ((_b = response.promptFeedback) === null || _b === void 0 ? void 0 : _b.blockReasonMessage) {
      message += `: ${response.promptFeedback.blockReasonMessage}`;
    }
  } else if ((_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0]) {
    const firstCandidate = response.candidates[0];
    if (hadBadFinishReason(firstCandidate)) {
      message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
      if (firstCandidate.finishMessage) {
        message += `: ${firstCandidate.finishMessage}`;
      }
    }
  }
  return message;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
var responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
function processStream(response) {
  const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
  const responseStream = getResponseStream(inputStream);
  const [stream1, stream2] = responseStream.tee();
  return {
    stream: generateResponseSequence(stream1),
    response: getResponsePromise(stream2)
  };
}
async function getResponsePromise(stream) {
  const allResponses = [];
  const reader = stream.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      return addHelpers(aggregateResponses(allResponses));
    }
    allResponses.push(value);
  }
}
function generateResponseSequence(stream) {
  return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
    const reader = stream.getReader();
    while (true) {
      const { value, done } = yield __await(reader.read());
      if (done) {
        break;
      }
      yield yield __await(addHelpers(value));
    }
  });
}
function getResponseStream(inputStream) {
  const reader = inputStream.getReader();
  const stream = new ReadableStream({
    start(controller) {
      let currentText = "";
      return pump();
      function pump() {
        return reader.read().then(({ value, done }) => {
          if (done) {
            if (currentText.trim()) {
              controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
              return;
            }
            controller.close();
            return;
          }
          currentText += value;
          let match = currentText.match(responseLineRE);
          let parsedResponse;
          while (match) {
            try {
              parsedResponse = JSON.parse(match[1]);
            } catch (e) {
              controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));
              return;
            }
            controller.enqueue(parsedResponse);
            currentText = currentText.substring(match[0].length);
            match = currentText.match(responseLineRE);
          }
          return pump();
        }).catch((e) => {
          let err = e;
          err.stack = e.stack;
          if (err.name === "AbortError") {
            err = new GoogleGenerativeAIAbortError("Request aborted when reading from the stream");
          } else {
            err = new GoogleGenerativeAIError("Error reading from the stream");
          }
          throw err;
        });
      }
    }
  });
  return stream;
}
function aggregateResponses(responses) {
  const lastResponse = responses[responses.length - 1];
  const aggregatedResponse = {
    promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback
  };
  for (const response of responses) {
    if (response.candidates) {
      let candidateIndex = 0;
      for (const candidate of response.candidates) {
        if (!aggregatedResponse.candidates) {
          aggregatedResponse.candidates = [];
        }
        if (!aggregatedResponse.candidates[candidateIndex]) {
          aggregatedResponse.candidates[candidateIndex] = {
            index: candidateIndex
          };
        }
        aggregatedResponse.candidates[candidateIndex].citationMetadata = candidate.citationMetadata;
        aggregatedResponse.candidates[candidateIndex].groundingMetadata = candidate.groundingMetadata;
        aggregatedResponse.candidates[candidateIndex].finishReason = candidate.finishReason;
        aggregatedResponse.candidates[candidateIndex].finishMessage = candidate.finishMessage;
        aggregatedResponse.candidates[candidateIndex].safetyRatings = candidate.safetyRatings;
        if (candidate.content && candidate.content.parts) {
          if (!aggregatedResponse.candidates[candidateIndex].content) {
            aggregatedResponse.candidates[candidateIndex].content = {
              role: candidate.content.role || "user",
              parts: []
            };
          }
          const newPart = {};
          for (const part of candidate.content.parts) {
            if (part.text) {
              newPart.text = part.text;
            }
            if (part.functionCall) {
              newPart.functionCall = part.functionCall;
            }
            if (part.executableCode) {
              newPart.executableCode = part.executableCode;
            }
            if (part.codeExecutionResult) {
              newPart.codeExecutionResult = part.codeExecutionResult;
            }
            if (Object.keys(newPart).length === 0) {
              newPart.text = "";
            }
            aggregatedResponse.candidates[candidateIndex].content.parts.push(newPart);
          }
        }
      }
      candidateIndex++;
    }
    if (response.usageMetadata) {
      aggregatedResponse.usageMetadata = response.usageMetadata;
    }
  }
  return aggregatedResponse;
}
async function generateContentStream(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(
    model,
    Task.STREAM_GENERATE_CONTENT,
    apiKey,
    /* stream */
    true,
    JSON.stringify(params),
    requestOptions
  );
  return processStream(response);
}
async function generateContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(
    model,
    Task.GENERATE_CONTENT,
    apiKey,
    /* stream */
    false,
    JSON.stringify(params),
    requestOptions
  );
  const responseJson = await response.json();
  const enhancedResponse = addHelpers(responseJson);
  return {
    response: enhancedResponse
  };
}
function formatSystemInstruction(input) {
  if (input == null) {
    return void 0;
  } else if (typeof input === "string") {
    return { role: "system", parts: [{ text: input }] };
  } else if (input.text) {
    return { role: "system", parts: [input] };
  } else if (input.parts) {
    if (!input.role) {
      return { role: "system", parts: input.parts };
    } else {
      return input;
    }
  }
}
function formatNewContent(request) {
  let newParts = [];
  if (typeof request === "string") {
    newParts = [{ text: request }];
  } else {
    for (const partOrString of request) {
      if (typeof partOrString === "string") {
        newParts.push({ text: partOrString });
      } else {
        newParts.push(partOrString);
      }
    }
  }
  return assignRoleToPartsAndValidateSendMessageRequest(newParts);
}
function assignRoleToPartsAndValidateSendMessageRequest(parts) {
  const userContent = { role: "user", parts: [] };
  const functionContent = { role: "function", parts: [] };
  let hasUserContent = false;
  let hasFunctionContent = false;
  for (const part of parts) {
    if ("functionResponse" in part) {
      functionContent.parts.push(part);
      hasFunctionContent = true;
    } else {
      userContent.parts.push(part);
      hasUserContent = true;
    }
  }
  if (hasUserContent && hasFunctionContent) {
    throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
  }
  if (!hasUserContent && !hasFunctionContent) {
    throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
  }
  if (hasUserContent) {
    return userContent;
  }
  return functionContent;
}
function formatCountTokensInput(params, modelParams) {
  var _a;
  let formattedGenerateContentRequest = {
    model: modelParams === null || modelParams === void 0 ? void 0 : modelParams.model,
    generationConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.generationConfig,
    safetySettings: modelParams === null || modelParams === void 0 ? void 0 : modelParams.safetySettings,
    tools: modelParams === null || modelParams === void 0 ? void 0 : modelParams.tools,
    toolConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.toolConfig,
    systemInstruction: modelParams === null || modelParams === void 0 ? void 0 : modelParams.systemInstruction,
    cachedContent: (_a = modelParams === null || modelParams === void 0 ? void 0 : modelParams.cachedContent) === null || _a === void 0 ? void 0 : _a.name,
    contents: []
  };
  const containsGenerateContentRequest = params.generateContentRequest != null;
  if (params.contents) {
    if (containsGenerateContentRequest) {
      throw new GoogleGenerativeAIRequestInputError("CountTokensRequest must have one of contents or generateContentRequest, not both.");
    }
    formattedGenerateContentRequest.contents = params.contents;
  } else if (containsGenerateContentRequest) {
    formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);
  } else {
    const content = formatNewContent(params);
    formattedGenerateContentRequest.contents = [content];
  }
  return { generateContentRequest: formattedGenerateContentRequest };
}
function formatGenerateContentInput(params) {
  let formattedRequest;
  if (params.contents) {
    formattedRequest = params;
  } else {
    const content = formatNewContent(params);
    formattedRequest = { contents: [content] };
  }
  if (params.systemInstruction) {
    formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);
  }
  return formattedRequest;
}
function formatEmbedContentInput(params) {
  if (typeof params === "string" || Array.isArray(params)) {
    const content = formatNewContent(params);
    return { content };
  }
  return params;
}
var VALID_PART_FIELDS = [
  "text",
  "inlineData",
  "functionCall",
  "functionResponse",
  "executableCode",
  "codeExecutionResult"
];
var VALID_PARTS_PER_ROLE = {
  user: ["text", "inlineData"],
  function: ["functionResponse"],
  model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
  // System instructions shouldn't be in history anyway.
  system: ["text"]
};
function validateChatHistory(history) {
  let prevContent = false;
  for (const currContent of history) {
    const { role, parts } = currContent;
    if (!prevContent && role !== "user") {
      throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
    }
    if (!POSSIBLE_ROLES.includes(role)) {
      throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
    }
    if (!Array.isArray(parts)) {
      throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
    }
    if (parts.length === 0) {
      throw new GoogleGenerativeAIError("Each Content should have at least one part");
    }
    const countFields = {
      text: 0,
      inlineData: 0,
      functionCall: 0,
      functionResponse: 0,
      fileData: 0,
      executableCode: 0,
      codeExecutionResult: 0
    };
    for (const part of parts) {
      for (const key of VALID_PART_FIELDS) {
        if (key in part) {
          countFields[key] += 1;
        }
      }
    }
    const validParts = VALID_PARTS_PER_ROLE[role];
    for (const key of VALID_PART_FIELDS) {
      if (!validParts.includes(key) && countFields[key] > 0) {
        throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
      }
    }
    prevContent = true;
  }
}
function isValidResponse(response) {
  var _a;
  if (response.candidates === void 0 || response.candidates.length === 0) {
    return false;
  }
  const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
  if (content === void 0) {
    return false;
  }
  if (content.parts === void 0 || content.parts.length === 0) {
    return false;
  }
  for (const part of content.parts) {
    if (part === void 0 || Object.keys(part).length === 0) {
      return false;
    }
    if (part.text !== void 0 && part.text === "") {
      return false;
    }
  }
  return true;
}
var SILENT_ERROR = "SILENT_ERROR";
var ChatSession = class {
  constructor(apiKey, model, params, _requestOptions = {}) {
    this.model = model;
    this.params = params;
    this._requestOptions = _requestOptions;
    this._history = [];
    this._sendPromise = Promise.resolve();
    this._apiKey = apiKey;
    if (params === null || params === void 0 ? void 0 : params.history) {
      validateChatHistory(params.history);
      this._history = params.history;
    }
  }
  /**
   * Gets the chat history so far. Blocked prompts are not added to history.
   * Blocked candidates are not added to history, nor are the prompts that
   * generated them.
   */
  async getHistory() {
    await this._sendPromise;
    return this._history;
  }
  /**
   * Sends a chat message and receives a non-streaming
   * {@link GenerateContentResult}.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async sendMessage(request, requestOptions = {}) {
    var _a, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request);
    const generateContentRequest = {
      safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,
      generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
      tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
      toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    let finalResult;
    this._sendPromise = this._sendPromise.then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions)).then((result) => {
      var _a2;
      if (isValidResponse(result.response)) {
        this._history.push(newContent);
        const responseContent = Object.assign({
          parts: [],
          // Response seems to come back without a role set.
          role: "model"
        }, (_a2 = result.response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0].content);
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(result.response);
        if (blockErrorMessage) {
          console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
      finalResult = result;
    });
    await this._sendPromise;
    return finalResult;
  }
  /**
   * Sends a chat message and receives the response as a
   * {@link GenerateContentStreamResult} containing an iterable stream
   * and a response promise.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async sendMessageStream(request, requestOptions = {}) {
    var _a, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request);
    const generateContentRequest = {
      safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,
      generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
      tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
      toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);
    this._sendPromise = this._sendPromise.then(() => streamPromise).catch((_ignored) => {
      throw new Error(SILENT_ERROR);
    }).then((streamResult) => streamResult.response).then((response) => {
      if (isValidResponse(response)) {
        this._history.push(newContent);
        const responseContent = Object.assign({}, response.candidates[0].content);
        if (!responseContent.role) {
          responseContent.role = "model";
        }
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(response);
        if (blockErrorMessage) {
          console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
    }).catch((e) => {
      if (e.message !== SILENT_ERROR) {
        console.error(e);
      }
    });
    return streamPromise;
  }
};
async function countTokens(apiKey, model, params, singleRequestOptions) {
  const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);
  return response.json();
}
async function embedContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
  return response.json();
}
async function batchEmbedContents(apiKey, model, params, requestOptions) {
  const requestsWithModel = params.requests.map((request) => {
    return Object.assign(Object.assign({}, request), { model });
  });
  const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
  return response.json();
}
var GenerativeModel = class {
  constructor(apiKey, modelParams, _requestOptions = {}) {
    this.apiKey = apiKey;
    this._requestOptions = _requestOptions;
    if (modelParams.model.includes("/")) {
      this.model = modelParams.model;
    } else {
      this.model = `models/${modelParams.model}`;
    }
    this.generationConfig = modelParams.generationConfig || {};
    this.safetySettings = modelParams.safetySettings || [];
    this.tools = modelParams.tools;
    this.toolConfig = modelParams.toolConfig;
    this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);
    this.cachedContent = modelParams.cachedContent;
  }
  /**
   * Makes a single non-streaming call to the model
   * and returns an object containing a single {@link GenerateContentResponse}.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async generateContent(request, requestOptions = {}) {
    var _a;
    const formattedParams = formatGenerateContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);
  }
  /**
   * Makes a single streaming call to the model and returns an object
   * containing an iterable stream that iterates over all chunks in the
   * streaming response as well as a promise that returns the final
   * aggregated response.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async generateContentStream(request, requestOptions = {}) {
    var _a;
    const formattedParams = formatGenerateContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);
  }
  /**
   * Gets a new {@link ChatSession} instance which can be used for
   * multi-turn chats.
   */
  startChat(startChatParams) {
    var _a;
    return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, startChatParams), this._requestOptions);
  }
  /**
   * Counts the tokens in the provided request.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async countTokens(request, requestOptions = {}) {
    const formattedParams = formatCountTokensInput(request, {
      model: this.model,
      generationConfig: this.generationConfig,
      safetySettings: this.safetySettings,
      tools: this.tools,
      toolConfig: this.toolConfig,
      systemInstruction: this.systemInstruction,
      cachedContent: this.cachedContent
    });
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  /**
   * Embeds the provided content.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async embedContent(request, requestOptions = {}) {
    const formattedParams = formatEmbedContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  /**
   * Embeds an array of {@link EmbedContentRequest}s.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);
  }
};
var GoogleGenerativeAI = class {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Gets a {@link GenerativeModel} instance for the provided model name.
   */
  getGenerativeModel(modelParams, requestOptions) {
    if (!modelParams.model) {
      throw new GoogleGenerativeAIError(`Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
    }
    return new GenerativeModel(this.apiKey, modelParams, requestOptions);
  }
  /**
   * Creates a {@link GenerativeModel} instance from provided content cache.
   */
  getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {
    if (!cachedContent.name) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `name` field.");
    }
    if (!cachedContent.model) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
    }
    const disallowedDuplicates = ["model", "systemInstruction"];
    for (const key of disallowedDuplicates) {
      if ((modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) && cachedContent[key] && (modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) !== cachedContent[key]) {
        if (key === "model") {
          const modelParamsComp = modelParams.model.startsWith("models/") ? modelParams.model.replace("models/", "") : modelParams.model;
          const cachedContentComp = cachedContent.model.startsWith("models/") ? cachedContent.model.replace("models/", "") : cachedContent.model;
          if (modelParamsComp === cachedContentComp) {
            continue;
          }
        }
        throw new GoogleGenerativeAIRequestInputError(`Different value for "${key}" specified in modelParams (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);
      }
    }
    const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });
    return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);
  }
};

// src/services/gemini.ts
var SYSTEM_INSTRUCTION = `YAML Property Rules:
1. Properties must be at the top of the note
2. Each property value should be concise (max 150 characters)
3. Title should be clear and descriptive (max 100 characters)
4. Description should be a brief summary (max 150 characters)
5. Keep all property values in a single line
6. Use quotes for values containing special characters
7. IMPORTANT: Never remove or modify the ![Thumbnail]() image tag if it exists`;
var GeminiService = class {
  constructor(apiKey, settings) {
    this.genAI = new GoogleGenerativeAI(apiKey);
    this.model = this.genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    this.settings = settings;
  }
  replaceVariables(prompt, variables) {
    return prompt.replace(/\${(\w+)}/g, (match, variable) => {
      return variables[variable] || match;
    });
  }
  extractFrontmatterAndContent(markdown) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
    const match = markdown.match(frontmatterRegex);
    if (!match) {
      return {
        frontmatter: null,
        frontmatterObj: {},
        content: markdown
      };
    }
    const frontmatter = match[0];
    const content = markdown.slice(frontmatter.length);
    const frontmatterContent = match[1];
    const frontmatterObj = {};
    const lines = frontmatterContent.split("\n");
    for (const line of lines) {
      const colonIndex = line.indexOf(":");
      if (colonIndex !== -1) {
        const key = line.slice(0, colonIndex).trim();
        let value = line.slice(colonIndex + 1).trim();
        if (value.startsWith('"') && value.endsWith('"')) {
          value = value.slice(1, -1);
        }
        frontmatterObj[key] = value;
      }
    }
    return {
      frontmatter,
      frontmatterObj,
      content
    };
  }
  generateFrontmatter(frontmatterObj) {
    const lines = ["---"];
    for (const [key, value] of Object.entries(frontmatterObj)) {
      const needsQuotes = typeof value === "string" && (value.includes(":") || value.includes('"') || value.includes("'") || value.includes("\n") || value.includes("#") || /^[0-9]/.test(value));
      const formattedValue = needsQuotes ? `"${value.replace(/"/g, '\\"')}"` : value;
      lines.push(`${key}: ${formattedValue}`);
    }
    lines.push("---\n");
    return lines.join("\n");
  }
  async processContent(markdown, prompts, variables, keepOriginalContent = true) {
    if (!this.model) {
      throw new Error("Gemini model not initialized");
    }
    if (!prompts) {
      return markdown;
    }
    const promptArray = Array.isArray(prompts) ? prompts : [prompts];
    const variablesMap = Array.isArray(prompts) ? variables : { single: variables };
    let { frontmatterObj, content } = this.extractFrontmatterAndContent(markdown);
    const thumbnailMatch = content.match(/^!\[Thumbnail\]\([^)]*\)\n*/);
    const thumbnailPart = thumbnailMatch ? thumbnailMatch[0] : "";
    let currentContent = content.replace(/^!\[Thumbnail\]\([^)]*\)\n*/, "");
    let originalContent = currentContent;
    let currentFrontmatter = frontmatterObj;
    const progressEvent = new CustomEvent("netclip-ai-progress", {
      detail: { total: promptArray.length, current: 0, promptName: "" }
    });
    for (let i = 0; i < promptArray.length; i++) {
      const prompt = promptArray[i];
      if (!prompt) continue;
      progressEvent.detail.current = i + 1;
      progressEvent.detail.promptName = prompt.name;
      document.dispatchEvent(progressEvent);
      const promptVars = Array.isArray(prompts) ? variablesMap[prompt.name] || {} : variablesMap.single;
      const processedPrompt = this.replaceVariables(prompt.prompt, {
        ...promptVars,
        article: currentContent
      });
      const singlePrompt = `System Instruction for YAML Properties:
${SYSTEM_INSTRUCTION}

Current Frontmatter:
${JSON.stringify(currentFrontmatter, null, 2)}

Content to Process:
${currentContent}

Your task:
${processedPrompt}

Return the result in this exact format:
---
[Your modified frontmatter here, following the system instructions]
---

[Your processed content here]

IMPORTANT: 
- Keep all required frontmatter properties
- Follow the system instructions for property formatting
- Include your processed content after the frontmatter
- DO NOT remove or modify the ![Thumbnail]() image tag if it exists
- Keep the thumbnail image tag exactly as is, at its original position`;
      const result = await this.model.generateContent(singlePrompt);
      const stepProcessedContent = result.response.text();
      const processedParts = this.extractFrontmatterAndContent(stepProcessedContent);
      if (processedParts.frontmatter) {
        currentFrontmatter = processedParts.frontmatterObj;
        currentContent = processedParts.content.trim();
      } else {
        currentContent = stepProcessedContent.trim();
      }
    }
    const newFrontmatter = this.generateFrontmatter(currentFrontmatter);
    let finalContent = "";
    if (keepOriginalContent) {
      finalContent = newFrontmatter + thumbnailPart + originalContent + "\n\n## AI Generated Content\n\n" + currentContent + "\n";
    } else {
      finalContent = newFrontmatter + thumbnailPart + currentContent + "\n";
    }
    return finalContent;
  }
};

// src/settingTabs.ts
var import_obsidian14 = require("obsidian");

// src/modal/deleteCategory.ts
var import_obsidian11 = require("obsidian");
var DeleteCategoryModal = class extends import_obsidian11.Modal {
  constructor(app, categoryName, onSubmit) {
    super(app);
    this.categoryName = categoryName;
    this.onSubmit = onSubmit;
    this.result = false;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Delete category" });
    contentEl.createEl("p", {
      text: `The folder "${this.categoryName}" is not empty. Are you sure you want to delete it and all its contents?`
    });
    const buttonContainer = contentEl.createEl("div", {
      cls: "netclip_button-container"
    });
    const confirmButton = buttonContainer.createEl("button", {
      text: "Delete",
      cls: "netclip_warning"
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "netclip_cancel"
    });
    cancelButton.onclick = () => {
      this.result = false;
      this.close();
    };
    confirmButton.onclick = () => {
      this.result = true;
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.onSubmit(this.result);
  }
};

// src/modal/folderSelection.ts
var import_obsidian12 = require("obsidian");
var FolderSelectionModal = class extends import_obsidian12.Modal {
  constructor(app, plugin) {
    super(app);
    this.selectedFolderPath = "";
    this.allFolders = [];
    this.plugin = plugin;
    this.selectedFolderPath = plugin.settings.parentFolderPath;
  }
  onChooseFolder(callback) {
    this.folderCallback = callback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("netclip-folder-selection-modal");
    contentEl.createEl("h2", { text: t("select_parent_folder") });
    contentEl.createEl("p", { text: t("select_parent_folder_desc") });
    const searchContainer = contentEl.createDiv("netclip-folder-search");
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search folders...",
      cls: "netclip-folder-search-input"
    });
    this.searchInput.addEventListener("input", () => {
      this.filterFolders(this.searchInput.value);
    });
    const rootSetting = new import_obsidian12.Setting(contentEl);
    const rootNameContainer = document.createElement("span");
    rootNameContainer.className = "netclip-folder-name-container";
    const rootIconContainer = document.createElement("span");
    rootIconContainer.className = "netclip-folder-icon";
    (0, import_obsidian12.setIcon)(rootIconContainer, "vault");
    rootNameContainer.appendChild(rootIconContainer);
    const rootTextSpan = document.createElement("span");
    rootTextSpan.textContent = t("vault_root");
    rootNameContainer.appendChild(rootTextSpan);
    rootSetting.nameEl.empty();
    rootSetting.nameEl.appendChild(rootNameContainer);
    rootSetting.setDesc(t("store_in_root_desc"));
    rootSetting.addButton((button) => button.setButtonText(t("select")).onClick(() => {
      this.selectedFolderPath = "";
      this.close();
      this.folderCallback("");
    }));
    this.allFolders = this.getAllFolders();
    contentEl.createEl("h3", { text: t("available_folders") });
    this.folderList = contentEl.createEl("div", { cls: "netclip-folder-list" });
    this.displayFolders(this.allFolders);
    new import_obsidian12.Setting(contentEl).addButton((button) => button.setButtonText(t("cancel")).onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  getAllFolders() {
    const folders = [];
    const getFolders = (folder) => {
      folders.push(folder);
      for (const child of folder.children) {
        if (child instanceof import_obsidian12.TFolder) {
          getFolders(child);
        }
      }
    };
    for (const child of this.app.vault.getRoot().children) {
      if (child instanceof import_obsidian12.TFolder) {
        getFolders(child);
      }
    }
    return folders.sort((a, b) => a.path.localeCompare(b.path));
  }
  displayFolders(folders) {
    this.folderList.empty();
    folders.forEach((folder) => {
      const folderPath = folder.path;
      const folderSetting = new import_obsidian12.Setting(this.folderList);
      const nameContainer = document.createElement("span");
      nameContainer.className = "netclip-folder-name-container";
      const iconContainer = document.createElement("span");
      iconContainer.className = "netclip-folder-icon";
      (0, import_obsidian12.setIcon)(iconContainer, "folder");
      nameContainer.appendChild(iconContainer);
      const textSpan = document.createElement("span");
      textSpan.textContent = folderPath;
      nameContainer.appendChild(textSpan);
      folderSetting.nameEl.empty();
      folderSetting.nameEl.appendChild(nameContainer);
      folderSetting.addButton((button) => button.setButtonText(t("select")).onClick(() => {
        this.selectedFolderPath = folderPath;
        this.close();
        this.folderCallback(folderPath);
      }));
    });
  }
  filterFolders(searchTerm) {
    const normalizedSearch = searchTerm.toLowerCase();
    const filteredFolders = this.allFolders.filter(
      (folder) => folder.path.toLowerCase().includes(normalizedSearch)
    );
    this.displayFolders(filteredFolders);
  }
};

// src/modal/promptModal.ts
var import_obsidian13 = require("obsidian");
var PromptModal = class extends import_obsidian13.Modal {
  constructor(app, prompt, onSave) {
    super(app);
    this.pendingVariableChanges = /* @__PURE__ */ new Map();
    this.prompt = prompt;
    this.tempPrompt = JSON.parse(JSON.stringify(prompt));
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.addClass("netclip_prompt_modal");
    contentEl.createEl("h2", { text: "Edit Prompt" });
    new import_obsidian13.Setting(contentEl).setName("Name").addText((text) => text.setValue(this.tempPrompt.name).onChange((value) => this.tempPrompt.name = value));
    new import_obsidian13.Setting(contentEl).setName("Prompt").setDesc("Use ${variableName} for variables. ${content} is a special built-in variable that contains the extracted content.").addTextArea((text) => text.setValue(this.tempPrompt.prompt).onChange((value) => this.tempPrompt.prompt = value));
    const variablesContainer = contentEl.createDiv();
    variablesContainer.createEl("h3", { text: "Variables" });
    Object.entries(this.tempPrompt.variables || {}).forEach(([key, values]) => {
      this.createVariableSection(variablesContainer, key, values);
    });
    new import_obsidian13.Setting(contentEl).addButton((btn) => btn.setButtonText("Add Variable").onClick(() => {
      const newKey = "newVariable" + Object.keys(this.tempPrompt.variables || {}).length;
      this.tempPrompt.variables = {
        ...this.tempPrompt.variables,
        [newKey]: []
      };
      this.createVariableSection(variablesContainer, newKey, []);
    }));
    new import_obsidian13.Setting(contentEl).addButton((btn) => btn.setButtonText("Save").setCta().onClick(() => {
      for (const [oldKey, change] of this.pendingVariableChanges) {
        const newVars = { ...this.tempPrompt.variables };
        if (oldKey !== change.newName) {
          delete newVars[oldKey];
        }
        newVars[change.newName] = change.values;
        this.tempPrompt.variables = newVars;
      }
      this.onSave(this.tempPrompt);
      this.close();
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.tempPrompt = JSON.parse(JSON.stringify(this.prompt));
      this.close();
    }));
  }
  createVariableSection(container, key, values) {
    const varContainer = container.createDiv({ cls: "prompt-variable-container" });
    new import_obsidian13.Setting(varContainer).setName("Variable Name").setDesc("Enter a name for your variable. Use ${variableName} in your prompt to reference it.").addText((text) => {
      text.setValue(key).setPlaceholder("Enter variable name");
      text.inputEl.addEventListener("input", (e) => {
        const newName = e.target.value;
        if (newName !== key) {
          this.pendingVariableChanges.set(key, {
            newName,
            values: this.tempPrompt.variables[key]
          });
        } else {
          this.pendingVariableChanges.delete(key);
        }
      });
      return text;
    });
    new import_obsidian13.Setting(varContainer).setName("Variable Values").setDesc("Add possible values for this variable, one per line").addTextArea((text) => {
      text.setPlaceholder("Enter possible values, one per line").setValue(values.join("\n")).onChange((value) => {
        const newValues = value.split("\n").filter((v) => v.trim());
        const existingChange = this.pendingVariableChanges.get(key);
        if (existingChange) {
          existingChange.values = newValues;
        } else {
          this.pendingVariableChanges.set(key, {
            newName: key,
            values: newValues
          });
        }
      });
      return text;
    });
    new import_obsidian13.Setting(varContainer).addButton((btn) => btn.setIcon("trash").setClass("netclip_trash").setTooltip("Delete variable").onClick(() => {
      const modal = new import_obsidian13.Modal(this.app);
      modal.titleEl.setText("Delete Variable");
      modal.contentEl.createDiv().setText(`Are you sure you want to delete the variable "${key}"?`);
      new import_obsidian13.Setting(modal.contentEl).addButton((btn2) => btn2.setButtonText("Cancel").onClick(() => {
        modal.close();
      })).addButton((btn2) => btn2.setButtonText("Delete").setWarning().onClick(() => {
        const newVars = { ...this.tempPrompt.variables };
        delete newVars[key];
        this.tempPrompt.variables = newVars;
        varContainer.remove();
        modal.close();
      }));
      modal.open();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settingTabs.ts
var import_obsidian15 = require("obsidian");
var NetClipSettingTab = class extends import_obsidian14.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.newFolderName = "";
    this.selectedTab = "Web view";
    this.tabContent = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  async onload() {
    await this.syncCategoriesFolders();
  }
  async syncCategoriesFolders() {
    const mainFolderPath = this.plugin.settings.parentFolderPath ? `${this.plugin.settings.parentFolderPath}/${this.plugin.settings.defaultFolderName}` : this.plugin.settings.defaultFolderName;
    const mainFolder = this.app.vault.getFolderByPath(mainFolderPath);
    if (!mainFolder) return;
    const subfolders = mainFolder.children.filter((file) => file instanceof import_obsidian14.TFolder).map((folder) => folder.name);
    this.plugin.settings.categories = subfolders;
    await this.plugin.saveSettings();
  }
  async deleteCategory(category) {
    const baseFolderPath = this.plugin.settings.parentFolderPath ? `${this.plugin.settings.parentFolderPath}/${this.plugin.settings.defaultFolderName}` : this.plugin.settings.defaultFolderName;
    const folderPath = `${baseFolderPath}/${category}`;
    const folder = this.app.vault.getFolderByPath(folderPath);
    if (!folder) {
      return false;
    }
    if (folder.children.length > 0) {
      const confirmed = await new Promise((resolve) => {
        new DeleteCategoryModal(
          this.app,
          category,
          (result) => resolve(result)
        ).open();
      });
      if (!confirmed) return false;
    }
    await this.app.fileManager.trashFile(folder);
    const index = this.plugin.settings.categories.indexOf(category);
    if (index > -1) {
      this.plugin.settings.categories.splice(index, 1);
      await this.plugin.saveSettings();
    }
    new import_obsidian14.Notice(t("category_deleted").replace("{0}", category));
    return true;
  }
  async createCategoryFolder(categoryName) {
    const baseFolderPath = this.plugin.settings.parentFolderPath ? `${this.plugin.settings.parentFolderPath}/${this.plugin.settings.defaultFolderName}` : this.plugin.settings.defaultFolderName;
    const folderPath = `${baseFolderPath}/${categoryName}`;
    const existingFolder = this.app.vault.getFolderByPath(folderPath);
    if (existingFolder) {
      new import_obsidian14.Notice(`Category "${categoryName}" already exists`);
      return false;
    }
    const baseFolder = this.app.vault.getFolderByPath(baseFolderPath);
    if (!baseFolder) {
      if (this.plugin.settings.parentFolderPath && !this.app.vault.getFolderByPath(this.plugin.settings.parentFolderPath)) {
        await this.app.vault.createFolder(this.plugin.settings.parentFolderPath);
      }
      await this.app.vault.createFolder(baseFolderPath);
    }
    await this.app.vault.createFolder(folderPath);
    return true;
  }
  async renameFolderAndUpdatePaths(oldPath, newPath) {
    const fullOldPath = this.plugin.settings.parentFolderPath ? `${this.plugin.settings.parentFolderPath}/${oldPath}` : oldPath;
    const fullNewPath = this.plugin.settings.parentFolderPath ? `${this.plugin.settings.parentFolderPath}/${newPath}` : newPath;
    const oldFolder = this.app.vault.getFolderByPath(fullOldPath);
    if (!oldFolder) {
      new import_obsidian14.Notice(t("folder_not_found").replace("{0}", fullOldPath));
      return false;
    }
    const newFolder = this.app.vault.getFolderByPath(fullNewPath);
    if (newFolder) {
      new import_obsidian14.Notice(t("folder_exists").replace("{0}", fullNewPath));
      return false;
    }
    await this.app.fileManager.renameFile(oldFolder, fullNewPath);
    for (const category of this.plugin.settings.categories) {
      const oldCategoryPath = `${fullOldPath}/${category}`;
      const newCategoryPath = `${fullNewPath}/${category}`;
      const categoryFolder = this.app.vault.getFolderByPath(oldCategoryPath);
      if (categoryFolder) {
        await this.app.fileManager.renameFile(categoryFolder, newCategoryPath);
      }
    }
    return true;
  }
  settingTitile() {
    new import_obsidian14.Setting(this.containerEl).setName("Netclip").setHeading();
  }
  addTabHeader() {
    const navContainer = this.containerEl.createEl("nav", {
      cls: "netclip-setting-header"
    });
    const navigateEl = navContainer.createDiv("netclip-setting-tab-group");
    const settingsEl = this.containerEl.createDiv("netclip-setting-content");
    this.createTabAndContent(
      "Web view",
      navigateEl,
      settingsEl,
      (el) => this.webViewSettings(el)
    );
    this.createTabAndContent(
      "Clipper",
      navigateEl,
      settingsEl,
      (el) => this.clipperTab(el)
    );
    this.createTabAndContent(
      "Home",
      navigateEl,
      settingsEl,
      (el) => this.homeTab(el)
    );
    this.createTabAndContent(
      "AI prompts",
      navigateEl,
      settingsEl,
      (el) => this.aiTab(el)
    );
    this.createTabAndContent(
      "Support",
      navigateEl,
      settingsEl,
      (el) => this.supportTab(el)
    );
  }
  createTabAndContent(tabName, navigateEl, containerEl, generateTabContent) {
    const displayTabContent = this.selectedTab === tabName;
    const tabEl = navigateEl.createDiv("netclip-navigation-item");
    if (displayTabContent) {
      tabEl.addClass("netclip-navigation-item-selected");
    }
    const iconMap = {
      "Web view": "globe",
      "Clipper": "scissors",
      "AI prompts": "bot",
      "Home": "home",
      "Support": "help"
    };
    if (iconMap[tabName]) {
      const iconEl = tabEl.createSpan({
        cls: "netclip-tab-icon"
      });
      (0, import_obsidian14.setIcon)(iconEl, iconMap[tabName]);
    }
    const translationKey = tabName.toLowerCase().replace(/\s+/g, "_") + "_tab";
    tabEl.createSpan().setText(t(translationKey));
    tabEl.onclick = () => {
      if (this.selectedTab === tabName) return;
      const tab = this.tabContent.get(tabName);
      (tab == null ? void 0 : tab.content).show();
      tabEl.addClass("netclip-navigation-item-selected");
      if (this.selectedTab) {
        const prevTab = this.tabContent.get(this.selectedTab);
        prevTab == null ? void 0 : prevTab.navButton.removeClass("netclip-navigation-item-selected");
        (prevTab == null ? void 0 : prevTab.content).hide();
      }
      this.selectedTab = tabName;
    };
    const tabContent = containerEl.createDiv("netclip-tab-settings");
    if (!displayTabContent) {
      tabContent.hide();
    }
    if (generateTabContent) {
      generateTabContent(tabContent);
    }
    this.tabContent.set(tabName, {
      content: tabContent,
      heading: tabContent,
      navButton: tabEl
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.settingTitile();
    this.addTabHeader();
  }
  webViewSettings(containerEl) {
    new import_obsidian14.Setting(containerEl).setName("Web view").setHeading();
    this.syncCategoriesFolders();
    new import_obsidian14.Setting(containerEl).setName("Search engine").setDesc("Choose your preferred search engine for the web view").addDropdown(
      (dropdown) => dropdown.addOption("google", "Google").addOption("youtube", "YouTube").addOption("bing", "Bing").addOption("perplexity", "Perplexity").addOption("duckduckgo", "Duckduckgo").addOption("genspark", "Genspark").addOption("kagi", "Kagi").setValue(this.plugin.settings.searchEngine).onChange(async (value) => {
        this.plugin.settings.searchEngine = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian14.Setting(containerEl).setName(t("default_url")).setDesc(t("default_url_desc")).addText(
      (text) => text.setPlaceholder(t("enter_default_url")).setValue(this.plugin.settings.defaultWebUrl).onChange(async (value) => {
        try {
          new URL(value);
          this.plugin.settings.defaultWebUrl = value;
          await this.plugin.saveSettings();
        } catch (e) {
          new import_obsidian14.Notice(t("invalid_url"));
        }
      })
    );
    new import_obsidian14.Setting(containerEl).setName(t("enable_ad_blocking")).setDesc(t("enable_ad_blocking_desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.adBlock.enabled).onChange(async (value) => {
        this.plugin.settings.adBlock.enabled = value;
        await this.plugin.saveSettings();
        this.display;
      })
    );
    new import_obsidian14.Setting(containerEl).setName(t("private_mode")).setDesc(t("private_mode_desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.privateMode).onChange(async (value) => {
        this.plugin.settings.privateMode = value;
        await this.plugin.saveSettings();
      })
    );
  }
  clipperTab(containerEl) {
    new import_obsidian14.Setting(containerEl).setName("Clipper").setHeading();
    new import_obsidian14.Setting(containerEl).setName("View position").setDesc("Choose where to display the clipper view").addDropdown(
      (dropdown) => dropdown.addOption("left", t("left_sidebar")).addOption("right", t("right_sidebar")).addOption("default", t("default_position")).setValue(this.plugin.settings.viewPosition).onChange(async (value) => {
        this.plugin.settings.viewPosition = value;
        await this.plugin.saveSettings();
        const leaves = this.app.workspace.getLeavesOfType(CLIPPER_VIEW);
        if (leaves.length > 0) {
          const activeLeaf = leaves[0];
          activeLeaf.detach();
          this.plugin.activateView();
        }
      })
    );
    new import_obsidian14.Setting(containerEl).setName("Card Display").setHeading();
    new import_obsidian14.Setting(containerEl).setName("Show Description").setDesc("Show article description in the card").addToggle((toggle) => toggle.setValue(this.plugin.settings.cardDisplay.showDescription).onChange(async (value) => {
      this.plugin.settings.cardDisplay.showDescription = value;
      await this.plugin.saveSettings();
      await this.plugin.updateHomeView();
    }));
    new import_obsidian14.Setting(containerEl).setName("Show Author").setDesc("Show article author in the card").addToggle((toggle) => toggle.setValue(this.plugin.settings.cardDisplay.showAuthor).onChange(async (value) => {
      this.plugin.settings.cardDisplay.showAuthor = value;
      await this.plugin.saveSettings();
      await this.plugin.updateHomeView();
    }));
    new import_obsidian14.Setting(containerEl).setName("Show Date").setDesc("Show article date in the card").addToggle((toggle) => toggle.setValue(this.plugin.settings.cardDisplay.showDate).onChange(async (value) => {
      this.plugin.settings.cardDisplay.showDate = value;
      await this.plugin.saveSettings();
      await this.plugin.updateHomeView();
    }));
    new import_obsidian14.Setting(containerEl).setName("Show Domain").setDesc("Show article source domain in the card").addToggle((toggle) => toggle.setValue(this.plugin.settings.cardDisplay.showDomain).onChange(async (value) => {
      this.plugin.settings.cardDisplay.showDomain = value;
      await this.plugin.saveSettings();
      await this.plugin.updateHomeView();
    }));
    new import_obsidian14.Setting(containerEl).setName("Show Thumbnail").setDesc("Show article thumbnail image in the card").addToggle((toggle) => toggle.setValue(this.plugin.settings.cardDisplay.showThumbnail).onChange(async (value) => {
      this.plugin.settings.cardDisplay.showThumbnail = value;
      await this.plugin.saveSettings();
      await this.plugin.updateHomeView();
    }));
    new import_obsidian14.Setting(containerEl).setName(t("parent_folder")).setDesc(t("parent_folder_desc")).addButton((button) => {
      const displayPath = this.plugin.settings.parentFolderPath || t("vault_root");
      return button.setClass("net-clip-button").setButtonText(displayPath).onClick(async () => {
        const modal = new FolderSelectionModal(this.app, this.plugin);
        modal.onChooseFolder(async (folderPath) => {
          this.plugin.settings.parentFolderPath = folderPath;
          await this.plugin.saveSettings();
          await this.plugin.FoldersExist();
          this.display();
        });
        modal.open();
      });
    });
    new import_obsidian14.Setting(containerEl).setName(t("change_folder_name")).setDesc(t("change_folder_name_desc")).addText((text) => {
      this.folderRenameText = text.inputEl;
      return text.setPlaceholder(t("enter_folder_name")).setValue(this.plugin.settings.defaultFolderName).onChange((value) => {
        var _a, _b;
        const newName = value.trim();
        if (newName === "") {
          (_a = this.confirmButton) == null ? void 0 : _a.setDisabled(true);
          return;
        }
        this.newFolderName = newName;
        (_b = this.confirmButton) == null ? void 0 : _b.setDisabled(false);
      });
    }).addButton((button) => {
      this.confirmButton = button.setButtonText(t("confirm")).setDisabled(true).onClick(async () => {
        if (this.newFolderName === this.plugin.settings.defaultFolderName) {
          this.confirmButton.setDisabled(true);
          return;
        }
        const success = await this.renameFolderAndUpdatePaths(
          this.plugin.settings.defaultFolderName,
          this.newFolderName
        );
        if (success) {
          this.plugin.settings.defaultFolderName = this.newFolderName;
          await this.plugin.saveSettings();
          new import_obsidian14.Notice(t("folder_renamed").replace("{0}", this.newFolderName));
          this.confirmButton.setDisabled(true);
        } else {
          this.folderRenameText.value = this.plugin.settings.defaultFolderName;
          this.confirmButton.setDisabled(true);
        }
      });
      return button;
    });
    new import_obsidian14.Setting(containerEl).setName("Default Quick Save Location").setDesc("Choose where to save clips when no domain-specific location is set").addButton((button) => {
      const currentPath = this.plugin.settings.defaultSaveLocations.defaultLocation;
      const displayPath = currentPath || "Choose Location";
      return button.setButtonText(displayPath).onClick(async () => {
        const modal = new FolderSelectionModal(this.app, this.plugin);
        modal.onChooseFolder(async (folderPath) => {
          this.plugin.settings.defaultSaveLocations.defaultLocation = folderPath;
          await this.plugin.saveSettings();
          this.display();
        });
        modal.open();
      });
    });
    new import_obsidian14.Setting(containerEl).setName("Domain-Specific Save Locations").setDesc("Set specific save locations for different websites").addButton((button) => button.setButtonText("Add New Domain").setCta().onClick(() => {
      const modal = new import_obsidian15.Modal(this.app);
      modal.titleEl.setText("Add Domain Save Location");
      const content = modal.contentEl;
      let domainValue = "";
      let locationValue = "";
      let locationButton;
      new import_obsidian14.Setting(content).setName("Domain").setDesc("Enter website domain (e.g., reddit.com)").addText((text) => text.setPlaceholder("Enter domain").onChange((value) => {
        domainValue = value.trim().toLowerCase();
      }));
      new import_obsidian14.Setting(content).setName("Save Location").addButton((button2) => {
        locationButton = button2;
        return button2.setButtonText("Choose Location").onClick(() => {
          const folderModal = new FolderSelectionModal(this.app, this.plugin);
          folderModal.onChooseFolder((path) => {
            locationValue = path;
            locationButton.setButtonText(path || "Choose Location");
          });
          folderModal.open();
        });
      });
      new import_obsidian14.Setting(content).addButton((button2) => button2.setButtonText("Save").setCta().onClick(async () => {
        if (domainValue && locationValue) {
          this.plugin.settings.defaultSaveLocations.domainMappings[domainValue] = locationValue;
          await this.plugin.saveSettings();
          this.display();
          modal.close();
        }
      })).addButton((button2) => button2.setButtonText("Cancel").onClick(() => {
        modal.close();
      }));
      modal.open();
    }));
    Object.entries(this.plugin.settings.defaultSaveLocations.domainMappings).forEach(([domain, location]) => {
      new import_obsidian14.Setting(containerEl).setName(domain).setDesc(`Saves to: ${location}`).addButton((button) => button.setButtonText("Edit").onClick(() => {
        const folderModal = new FolderSelectionModal(this.app, this.plugin);
        folderModal.onChooseFolder(async (path) => {
          this.plugin.settings.defaultSaveLocations.domainMappings[domain] = path;
          await this.plugin.saveSettings();
          this.display();
        });
        folderModal.open();
      })).addButton((button) => button.setButtonText("Delete").onClick(async () => {
        delete this.plugin.settings.defaultSaveLocations.domainMappings[domain];
        await this.plugin.saveSettings();
        this.display();
      }));
    });
    new import_obsidian14.Setting(containerEl).setName(t("categories")).setDesc(t("categories_desc")).addText((text) => {
      const textComponent = text.setPlaceholder(t("new_category_name"));
      const storedTextComponent = textComponent;
      textComponent.inputEl.onkeydown = async (e) => {
        if (e.key === "Enter") {
          const value = textComponent.getValue().trim();
          if (value && !this.plugin.settings.categories.includes(value)) {
            if (await this.createCategoryFolder(value)) {
              this.plugin.settings.categories.push(value);
              await this.plugin.saveSettings();
              textComponent.setValue("");
              this.display();
            }
          }
        }
      };
      return textComponent;
    }).addButton((button) => {
      return button.setButtonText(t("create")).onClick(async () => {
        const settingItem = button.buttonEl.closest(".setting-item");
        if (!settingItem) return;
        const textInput = settingItem.querySelector("input");
        if (!textInput) return;
        const value = textInput.value.trim();
        if (!value) {
          new import_obsidian14.Notice(t("please_enter_category_name"));
          return;
        }
        if (this.plugin.settings.categories.includes(value)) {
          new import_obsidian14.Notice(t("category_exists").replace("{0}", value));
          return;
        }
        if (await this.createCategoryFolder(value)) {
          this.plugin.settings.categories.push(value);
          await this.plugin.saveSettings();
          textInput.value = "";
          this.display();
          new import_obsidian14.Notice(t("category_created").replace("{0}", value));
        }
      });
    });
    this.plugin.settings.categories.forEach((category) => {
      const setting = new import_obsidian14.Setting(containerEl).setName(category).addButton((btn) => btn.setClass("netclip_trash").setIcon("trash").onClick(async () => {
        if (await this.deleteCategory(category)) {
          this.display();
        }
      })).addText((text) => {
        text.setPlaceholder(t("enter_icon_name")).setValue(this.plugin.settings.categoryIcons[category] || "").onChange(async (value) => {
          if (value) {
            this.plugin.settings.categoryIcons[category] = value;
          } else {
            delete this.plugin.settings.categoryIcons[category];
          }
          await this.plugin.saveSettings();
        });
        return text;
      });
      if (this.plugin.settings.categoryIcons[category]) {
        setting.setDesc(`Current icon: ${this.plugin.settings.categoryIcons[category]}`);
      }
    });
  }
  homeTab(containerEl) {
    new import_obsidian14.Setting(containerEl).setName(t("home_tab")).setHeading();
    new import_obsidian14.Setting(containerEl).setName(t("replace_new_tabs")).setDesc(t("replace_new_tabs_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.replaceTabHome).onChange(async (value) => {
        this.plugin.settings.replaceTabHome = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian14.Setting(containerEl).setName(t("show_clock")).setDesc(t("show_clock_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showClock).onChange(async (value) => {
        this.plugin.settings.showClock = value;
        await this.plugin.saveSettings();
        this.plugin.refreshHomeViews();
      });
    });
    new import_obsidian14.Setting(containerEl).setName(t("show_recent_files")).setDesc(t("show_recent_files_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.homeTab.showRecentFiles).onChange(async (value) => {
        this.plugin.settings.homeTab.showRecentFiles = value;
        await this.plugin.saveSettings();
        this.plugin.refreshHomeViews();
      });
    });
    new import_obsidian14.Setting(containerEl).setName(t("show_saved_articles")).setDesc(t("show_saved_articles_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.homeTab.showSavedArticles).onChange(async (value) => {
        this.plugin.settings.homeTab.showSavedArticles = value;
        await this.plugin.saveSettings();
        this.plugin.refreshHomeViews();
      });
    });
    new import_obsidian14.Setting(containerEl).setName("Background Image").setDesc("Set a background image for the home tab (enter image URL)").addText((text) => text.setPlaceholder("Enter image URL").setValue(this.plugin.settings.homeTab.backgroundImage).onChange(async (value) => {
      this.plugin.settings.homeTab.backgroundImage = value;
      await this.plugin.saveSettings();
      this.plugin.refreshHomeViews();
    })).addButton((button) => button.setButtonText("Clear").onClick(async () => {
      this.plugin.settings.homeTab.backgroundImage = "";
      await this.plugin.saveSettings();
      this.plugin.refreshHomeViews();
    })).addButton((button) => button.setButtonText("Test").onClick(() => {
      const url = this.plugin.settings.homeTab.backgroundImage;
      if (url) {
        const img = new Image();
        img.onload = () => {
          new import_obsidian14.Notice("Background image loaded successfully");
        };
        img.onerror = () => {
          new import_obsidian14.Notice("Failed to load background image. Please check the URL");
        };
        img.src = url;
      }
    }));
    new import_obsidian14.Setting(containerEl).setName("Background Blur").setDesc("Adjust the blur intensity of the background image (0-20)").addSlider((slider) => slider.setLimits(0, 20, 1).setValue(this.plugin.settings.homeTab.backgroundBlur).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.homeTab.backgroundBlur = value;
      await this.plugin.saveSettings();
      this.plugin.refreshHomeViews();
    }));
    new import_obsidian14.Setting(containerEl).setName("Text Color").setDesc("Choose the text color when background image is set").addColorPicker((color) => color.setValue(this.plugin.settings.homeTab.textColor).onChange(async (value) => {
      this.plugin.settings.homeTab.textColor = value;
      await this.plugin.saveSettings();
      this.plugin.refreshHomeViews();
    }));
    new import_obsidian14.Setting(containerEl).setName("Text Brightness").setDesc("Adjust the brightness of the text (0-100%)").addSlider((slider) => slider.setLimits(0, 100, 5).setValue(this.plugin.settings.homeTab.textBrightness).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.homeTab.textBrightness = value;
      await this.plugin.saveSettings();
      this.plugin.refreshHomeViews();
    }));
  }
  aiTab(containerEl) {
    new import_obsidian14.Setting(containerEl).setName("AI prompts").setHeading();
    new import_obsidian14.Setting(containerEl).setName(t("enable_ai")).setDesc(t("enable_ai_desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAI).onChange(async (value) => {
        this.plugin.settings.enableAI = value;
        await this.plugin.saveSettings();
        containerEl.empty();
        this.aiTab(containerEl);
      })
    );
    new import_obsidian14.Setting(containerEl).setName(t("gemini_api_key")).setDesc(t("gemini_api_key_desc")).addText(
      (text) => text.setPlaceholder(t("enter_api_key")).setValue(this.plugin.settings.geminiApiKey).onChange(async (value) => {
        this.plugin.settings.geminiApiKey = value;
        if (value) {
          this.plugin.geminiService = new GeminiService(value, this.plugin.settings);
        } else {
          this.plugin.geminiService = null;
        }
        await this.plugin.saveSettings();
      })
    );
    const infoDiv = containerEl.createDiv("netclip-info-box");
    const infoContent = infoDiv.createDiv("netclip-info-content");
    const infoIcon = infoContent.createSpan("netclip-info-icon");
    (0, import_obsidian14.setIcon)(infoIcon, "info");
    const textSpan = infoContent.createSpan();
    textSpan.setText("Learn how to create and use AI prompts effectively");
    const detailsLink = infoContent.createEl("a", {
      text: "View Documentation \u2192",
      href: "https://github.com/Elhary/Obsidian-NetClip/blob/main/AI_PROMPTS.md"
    });
    detailsLink.addClass("netclip-details-link");
    detailsLink.setAttribute("target", "_blank");
    if (this.plugin.settings.enableAI) {
      new import_obsidian14.Setting(containerEl).setName(t("ai_prompts")).setDesc(t("ai_prompts_desc")).addButton((button) => button.setButtonText(t("add_new_prompt")).setCta().onClick(() => {
        const newPrompt = {
          name: "",
          prompt: "",
          enabled: false,
          variables: {}
        };
        new PromptModal(this.app, newPrompt, async (prompt) => {
          this.plugin.settings.prompts.push(prompt);
          await this.plugin.saveSettings();
          this.display();
        }).open();
      }));
      new import_obsidian14.Setting(containerEl).setName(t("export_prompts")).setDesc(t("export_prompts_desc")).addButton((button) => button.setButtonText(t("export_prompts")).onClick(() => this.exportPrompts(this.plugin.settings.prompts)));
      new import_obsidian14.Setting(containerEl).setName(t("import_prompts")).setDesc(t("import_prompts_desc")).addButton((button) => button.setButtonText(t("import_prompts")).onClick(() => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = async (e) => {
          var _a;
          const file = (_a = e.target.files) == null ? void 0 : _a[0];
          if (file) {
            try {
              const text = await file.text();
              const prompts = JSON.parse(text);
              if (!Array.isArray(prompts) || !prompts.every(
                (p) => typeof p === "object" && typeof p.name === "string" && typeof p.prompt === "string" && typeof p.enabled === "boolean" && typeof p.variables === "object"
              )) {
                throw new Error("Invalid format");
              }
              this.plugin.settings.prompts = prompts;
              await this.plugin.saveSettings();
              new import_obsidian14.Notice(t("import_success"));
              this.display();
            } catch (error) {
              new import_obsidian14.Notice(t("import_error"));
            }
          }
        };
        input.click();
      }));
      this.plugin.settings.prompts.forEach((prompt, index) => {
        new import_obsidian14.Setting(containerEl).setName(prompt.name).addToggle((toggle) => toggle.setTooltip(prompt.enabled ? t("hide_in_clipper_desc") : t("show_in_clipper_desc")).setValue(prompt.enabled).onChange(async (value) => {
          this.plugin.settings.prompts[index].enabled = value;
          await this.plugin.saveSettings();
          this.display();
        })).addButton((button) => button.setButtonText(t("edit_prompt")).onClick(() => {
          new PromptModal(this.app, prompt, async (updatedPrompt) => {
            this.plugin.settings.prompts[index] = updatedPrompt;
            await this.plugin.saveSettings();
            this.display();
          }).open();
        })).addButton((button) => button.setButtonText(t("export_prompt")).setTooltip(t("export_single_prompt_desc")).onClick(() => this.exportPrompts([prompt], prompt.name))).addButton((button) => button.setButtonText(t("delete_prompt")).onClick(async () => {
          const modal = new import_obsidian15.Modal(this.app);
          modal.titleEl.setText("Delete Prompt");
          modal.contentEl.createDiv().setText(`Are you sure you want to delete the prompt "${prompt.name}"?`);
          new import_obsidian14.Setting(modal.contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
            modal.close();
          })).addButton((btn) => btn.setButtonText("Delete").setWarning().onClick(async () => {
            this.plugin.settings.prompts.splice(index, 1);
            await this.plugin.saveSettings();
            this.display();
            modal.close();
          }));
          modal.open();
        }));
      });
    }
  }
  exportPrompts(prompts, filename) {
    const promptsJson = JSON.stringify(prompts, null, 2);
    const blob = new Blob([promptsJson], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename ? `netclip-prompt-${filename}.json` : "netclip-prompts.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  supportTab(containerEl) {
    new import_obsidian14.Setting(containerEl).setName(t("support_tab")).setHeading();
    new import_obsidian14.Setting(containerEl).setName(t("support_development")).setDesc(t("support_development_desc")).setClass("netclip-support-buttons");
    const buttonsContainer = containerEl.createDiv("netclip-support-buttons-container");
    const githubContainer = buttonsContainer.createDiv("netclip-support-button");
    const githubLink = githubContainer.createEl("a", {
      href: "https://github.com/Elhary/Obsidian-NetClip"
    });
    githubLink.setAttribute("target", "_blank");
    githubLink.createEl("img", {
      attr: {
        src: "https://img.shields.io/github/stars/Elhary/Obsidian-NetClip?style=social",
        alt: t("github_repo"),
        height: "40"
      }
    });
    const kofiContainer = buttonsContainer.createDiv("netclip-support-button");
    const kofiLink = kofiContainer.createEl("a", {
      href: "https://ko-fi.com/elharis"
    });
    kofiLink.setAttribute("target", "_blank");
    kofiLink.createEl("img", {
      attr: {
        src: "https://storage.ko-fi.com/cdn/kofi3.png?v=3",
        height: "40"
      }
    });
  }
};

// src/view/HomeTab.ts
var import_obsidian17 = require("obsidian");

// src/modal/ShortcutModal.ts
var import_obsidian16 = require("obsidian");
var ShortcutModal = class extends import_obsidian16.Modal {
  constructor(app, shortcut, onSubmit) {
    super(app);
    this.shortcut = shortcut;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.shortcut ? "Edit shortcut" : "Add shortcut" });
    new import_obsidian16.Setting(contentEl).setName("URL").setDesc("Enter the website URL").addText((text) => {
      var _a;
      this.urlInput = text.inputEl;
      text.setValue(((_a = this.shortcut) == null ? void 0 : _a.url) || "");
      text.setPlaceholder("https://example.com");
    });
    new import_obsidian16.Setting(contentEl).setName("Title (optional)").setDesc("Enter shorcut title").addText((text) => {
      var _a;
      this.nameInput = text.inputEl;
      text.setValue(((_a = this.shortcut) == null ? void 0 : _a.name) || "");
      text.setPlaceholder("My shortcut");
    });
    const buttonContainer = contentEl.createDiv({ cls: "netclip-modal-buttons" });
    buttonContainer.createEl("button", {
      text: t("cancel") || "Cancel",
      cls: "netclip-modal-button-cancel"
    }).addEventListener("click", () => {
      this.close();
    });
    buttonContainer.createEl("button", {
      text: this.shortcut ? t("update") || "Update" : t("add") || "Add",
      cls: "netclip-modal-button-submit"
    }).addEventListener("click", () => {
      this.handleSubmit();
    });
  }
  handleSubmit() {
    var _a;
    const url = this.urlInput.value.trim();
    if (!url) {
      this.urlInput.classList.add("is-invalid");
      return;
    }
    let finalUrl = url;
    if (!finalUrl.startsWith("http://") && !finalUrl.startsWith("https://")) {
      finalUrl = "https://" + finalUrl;
    }
    const name = this.nameInput.value.trim();
    const shortcut = {
      id: ((_a = this.shortcut) == null ? void 0 : _a.id) || "",
      name,
      url: finalUrl
    };
    this.onSubmit(shortcut);
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/view/HomeTab.ts
var HOME_TAB_VIEW = "netclip-home-tab-view";
var HomeTabView = class extends import_obsidian17.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.shortcuts = [];
    this.navigation = false;
    this.allowNoFile = true;
    this.icon = "home";
    this.plugin = plugin;
    this.shortcuts = this.plugin.settings.shortcuts || [];
    this.addAction("globe", "Open web view", (evt) => {
      this.openWebView();
    });
    this.addAction("newspaper", "newspaper", (evt) => {
      this.openCliperView();
    });
    this.addAction("refresh-cw", "reload", (evt) => {
      this.refreshContent();
    });
    this.addAction("scissors", "Open Clip", (evt) => {
      this.showClipModal();
    });
    this.addAction("file-plus", "create new file", (evt) => {
      this.createNewFile();
    });
  }
  getViewType() {
    return HOME_TAB_VIEW;
  }
  getDisplayText() {
    return "Home";
  }
  getState() {
    return {};
  }
  setState(state, result) {
    return;
  }
  updateBackgroundImage() {
    const { backgroundImage, backgroundBlur, textColor, textBrightness } = this.plugin.settings.homeTab;
    const leafContent = this.containerEl.closest('.workspace-leaf-content[data-type="netclip-home-tab-view"]');
    if (leafContent) {
      if (backgroundImage) {
        leafContent.setAttribute(
          "style",
          `--background-image: url('${backgroundImage}'); 
                     --background-blur: ${backgroundBlur}px;
                     --custom-text-color: ${textColor};
                     --text-brightness: ${textBrightness}%;`
        );
      } else {
        leafContent.removeAttribute("style");
      }
    }
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    this.updateBackgroundImage();
    if (this.plugin.settings.showClock) {
      const clockSection = container.createEl("div", { cls: "netclip-clock-section" });
      const timeEl = clockSection.createEl("div", { cls: "netclip-time" });
      const dateEl = clockSection.createEl("div", { cls: "netclip-date" });
      this.updateClock(timeEl, dateEl);
      const clockInterval = window.setInterval(() => {
        this.updateClock(timeEl, dateEl);
      }, 1e3);
      this.registerInterval(clockInterval);
    }
    const searchContainer = container.createEl("div", { cls: "netclip-home-tab-search" });
    const searchIcon = searchContainer.createEl("span", { cls: "netclip-search-icon" });
    (0, import_obsidian17.setIcon)(searchIcon, "search");
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      cls: "netclip-search-input",
      placeholder: t("search_web") || "Search the web..."
    });
    this.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && this.searchInput.value.trim()) {
        this.openWebSearch(this.searchInput.value.trim());
      }
    });
    const shortcutsSection = container.createEl("div", { cls: "netclip-shortcuts-section" });
    this.shortcutsContainer = shortcutsSection.createEl("div", { cls: "netclip-shortcuts-container" });
    this.renderShortcuts();
    const sectionsContainer = container.createEl("div", { cls: "netclip-home-tab-sections" });
    if (this.plugin.settings.homeTab.showRecentFiles) {
      const recentSection = sectionsContainer.createEl("div", { cls: "netclip-home-tab-section" });
      const titleContainer = recentSection.createEl("div", { cls: "netclip-section-title" });
      const titleIcon = titleContainer.createEl("span", { cls: "netclip-section-icon" });
      (0, import_obsidian17.setIcon)(titleIcon, "clock");
      const titleText = titleContainer.createEl("h3", { text: "Recent Files" });
      const recentFilesContainer = recentSection.createEl("div", { cls: "netclip-recent-files" });
      await this.renderRecentFiles(recentFilesContainer);
    }
    if (this.plugin.settings.homeTab.showSavedArticles) {
      const savedSection = sectionsContainer.createEl("div", { cls: "netclip-home-tab-section" });
      const savedTitleContainer = savedSection.createEl("div", { cls: "netclip-section-title" });
      const savedTitleIcon = savedTitleContainer.createEl("span", { cls: "netclip-section-icon" });
      (0, import_obsidian17.setIcon)(savedTitleIcon, "bookmark");
      const savedTitleText = savedTitleContainer.createEl("h3", { text: t("saved_articles") || "Saved Articles" });
      const savedArticlesContainer = savedSection.createEl("div", { cls: "netclip-saved-articles" });
      await this.renderSavedArticles(savedArticlesContainer);
    }
  }
  onPaneMenu(menu, source) {
    super.onPaneMenu(menu, source);
    menu.addItem((item) => {
      item.setTitle("Add shortcut").setIcon("plus").onClick(() => this.addShortcutModal());
    });
    menu.addItem((item) => {
      item.setTitle("open clipper").setIcon("scissors").onClick(() => this.showClipModal());
    });
    menu.addItem((item) => {
      item.setTitle("Refresh").setIcon("refresh-cw").onClick(() => this.refreshContent());
    });
    menu.addItem((item) => {
      item.setTitle("Create new file").setIcon("file").onClick(() => this.createNewFile());
    });
  }
  onResize() {
  }
  async onClose() {
    this.containerEl.empty();
  }
  renderShortcuts() {
    this.shortcutsContainer.empty();
    const shortcutsGrid = this.shortcutsContainer.createEl("div", { cls: "netclip-shortcuts-grid" });
    this.shortcuts.forEach((shortcut) => {
      this.shortcutEl(shortcutsGrid, shortcut);
    });
    const addShortcutButton = shortcutsGrid.createEl("div", { cls: "netclip-shortcut-add" });
    const addIcon = addShortcutButton.createEl("div", { cls: "netclip-shortcut-add-icon" });
    (0, import_obsidian17.setIcon)(addIcon, "plus");
    addShortcutButton.createEl("div", { cls: "netclip-shortcut-add-text" });
    addShortcutButton.addEventListener("click", () => {
      this.addShortcutModal();
    });
  }
  shortcutEl(container, shortcut) {
    const shortcutEl = container.createEl("div", { cls: "netclip-shortcut" });
    const iconContainer = shortcutEl.createEl("div", { cls: "netclip-shortcut-icon" });
    const domain = getDomain(shortcut.url);
    const faviconUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=128`;
    iconContainer.createEl("img", {
      cls: "netclip-shortcut-favicon",
      attr: { src: faviconUrl }
    });
    shortcutEl.createEl("div", {
      cls: "netclip-shortcut-name",
      text: shortcut.name || ""
    });
    shortcutEl.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.openShortcut(shortcut);
    });
    shortcutEl.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      this.shortcutContextMenu(shortcut, e);
    });
  }
  openShortcut(shortcut) {
    const leaf = this.app.workspace.getLeaf(true);
    leaf.setViewState({
      type: VIEW_TYPE_WORKSPACE_WEBVIEW,
      state: { url: shortcut.url }
    });
    this.app.workspace.revealLeaf(leaf);
  }
  shortcutContextMenu(shortcut, event) {
    const menu = new import_obsidian17.Menu();
    menu.addItem((item) => {
      item.setTitle("Edit shortcut").setIcon("pencil").onClick(() => this.editShortcutModal(shortcut));
    });
    menu.addItem((item) => {
      item.setTitle("Remove shortcut").setIcon("trash").onClick(() => this.removeShortcut(shortcut));
    });
    menu.addItem((item) => {
      item.setTitle("Add shortcut").setIcon("plus").onClick(() => this.addShortcutModal());
    });
    menu.showAtMouseEvent(event);
  }
  async addShortcutModal() {
    const modal = new ShortcutModal(this.app, null, (shortcut) => {
      if (shortcut) {
        this.addShortcut(shortcut);
      }
    });
    modal.open();
  }
  async editShortcutModal(shortcut) {
    const modal = new ShortcutModal(this.app, shortcut, (updatedShortcut) => {
      if (updatedShortcut) {
        this.updateShortcut(shortcut.id, updatedShortcut);
      }
    });
    modal.open();
  }
  addShortcut(shortcut) {
    shortcut.id = Date.now().toString();
    this.shortcuts.push(shortcut);
    this.saveShortcuts();
    this.renderShortcuts();
  }
  updateShortcut(id, updatedShortcut) {
    const index = this.shortcuts.findIndex((s) => s.id === id);
    if (index !== -1) {
      updatedShortcut.id = id;
      this.shortcuts[index] = updatedShortcut;
      this.saveShortcuts();
      this.renderShortcuts();
    }
  }
  removeShortcut(shortcut) {
    this.shortcuts = this.shortcuts.filter((s) => s.id !== shortcut.id);
    this.saveShortcuts();
    this.renderShortcuts();
  }
  async saveShortcuts() {
    this.plugin.settings.shortcuts = this.shortcuts;
    await this.plugin.saveSettings();
  }
  async renderRecentFiles(container, filter = "") {
    container.empty();
    let files = this.app.vault.getMarkdownFiles().sort((a, b) => b.stat.mtime - a.stat.mtime).slice(0, 10);
    if (filter) {
      const lowerFilter = filter.toLowerCase();
      files = files.filter((file) => file.basename.toLowerCase().includes(lowerFilter));
    }
    if (files.length === 0) {
      container.createEl("p", { text: t("no_recent_files") || "No recent files found" });
      return;
    }
    for (const file of files) {
      const fileItem = container.createEl("div", { cls: "netclip-file-item" });
      const fileIcon = fileItem.createEl("span", { cls: "netclip-file-icon" });
      (0, import_obsidian17.setIcon)(fileIcon, "file-text");
      fileItem.createEl("span", { text: file.basename, cls: "netclip-file-name" });
      const date = new Date(file.stat.mtime);
      const dateStr = `${date.toLocaleDateString()} ${date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`;
      fileItem.createEl("span", { text: dateStr, cls: "netclip-file-date" });
      fileItem.addEventListener("click", () => this.openFile(file));
    }
  }
  async renderSavedArticles(container) {
    container.empty();
    const baseFolderPath = this.plugin.settings.parentFolderPath ? `${this.plugin.settings.parentFolderPath}/${this.plugin.settings.defaultFolderName}` : this.plugin.settings.defaultFolderName;
    let files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(baseFolderPath));
    if (files.length === 0) {
      container.createEl("p", { text: t("no_saved_articles") || "No saved articles found" });
      return;
    }
    files = this.shuffleArray(files).slice(0, 9);
    const articlesGrid = container.createEl("div", { cls: "netclip-articles-grid" });
    for (const file of files) {
      const content = await this.app.vault.cachedRead(file);
      const articleCard = articlesGrid.createEl("div", { cls: "netclip-article-card" });
      const imageContainer = articleCard.createEl("div", { cls: "netclip-article-image-container" });
      const frontmatterMatch = content.match(/^---[\s\S]*?thumbnail: "([^"]+)"[\s\S]*?---/);
      let thumbnailUrl = frontmatterMatch ? frontmatterMatch[1] : null;
      if (!thumbnailUrl) {
        const thumbnailMatch = content.match(/!\[Thumbnail\]\((.+)\)/);
        thumbnailUrl = thumbnailMatch ? thumbnailMatch[1] : null;
      }
      if (!thumbnailUrl) {
        thumbnailUrl = await findFirstImageInNote(this.app, content);
      }
      imageContainer.createEl("img", {
        cls: "netclip-article-thumbnail",
        attr: {
          src: thumbnailUrl || DEFAULT_IMAGE,
          loading: "lazy"
        }
      });
      const contentContainer = articleCard.createEl("div", { cls: "netclip-article-content" });
      let displayTitle = file.basename;
      displayTitle = displayTitle.replace(/_/g, " ");
      if (displayTitle.includes(" - ")) {
        displayTitle = displayTitle.substring(0, displayTitle.indexOf(" - "));
      }
      contentContainer.createEl("div", {
        cls: "netclip-article-title",
        text: displayTitle
      });
      const metaContainer = contentContainer.createEl("div", { cls: "netclip-article-meta" });
      const urlMatch = content.match(/source: "([^"]+)"/);
      if (urlMatch) {
        const sourceContainer = metaContainer.createEl("div", { cls: "netclip-article-source" });
        const domainName = getDomain(urlMatch[1]);
        sourceContainer.setText(domainName);
        const dateContainer = metaContainer.createEl("div", { cls: "netclip-article-date" });
        const creationDate = new Date(file.stat.ctime);
        const formattedDate = creationDate.toLocaleDateString(void 0, {
          month: "short",
          day: "numeric"
        });
        dateContainer.setText(formattedDate);
      }
      articleCard.addEventListener("click", () => this.openFile(file));
    }
    const viewAllBtn = container.createEl("button", {
      cls: "netclip-view-all-btn",
      text: t("view_all") || "View All Articles"
    });
    viewAllBtn.addEventListener("click", () => this.plugin.activateView());
  }
  shuffleArray(array) {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
  }
  openFile(file) {
    this.app.workspace.getLeaf(false).openFile(file);
  }
  openWebSearch(query) {
    const searchEngine = this.plugin.settings.searchEngine || "google";
    let searchUrl = "";
    switch (searchEngine) {
      case "google":
        searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
        break;
      case "bing":
        searchUrl = `https://www.bing.com/search?q=${encodeURIComponent(query)}`;
        break;
      case "duckduckgo":
        searchUrl = `https://duckduckgo.com/?q=${encodeURIComponent(query)}`;
        break;
      case "youtube":
        searchUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`;
        break;
      case "perplexity":
        searchUrl = `https://www.perplexity.ai/search?q=${encodeURIComponent(query)}`;
        break;
    }
    const leaf = this.app.workspace.getLeaf(true);
    leaf.setViewState({
      type: VIEW_TYPE_WORKSPACE_WEBVIEW,
      state: { url: searchUrl }
    });
    this.app.workspace.revealLeaf(leaf);
  }
  updateClock(timeEl, dateEl) {
    const now = /* @__PURE__ */ new Date();
    const hours = now.getHours().toString().padStart(2, "0");
    const minutes = now.getMinutes().toString().padStart(2, "0");
    timeEl.textContent = `${hours}:${minutes}`;
    const options = {
      weekday: "long",
      month: "long",
      day: "numeric"
    };
    dateEl.textContent = now.toLocaleDateString(void 0, options);
  }
  openWebView() {
    const defaultUrl = this.plugin.settings.defaultWebUrl || "https://google.com";
    const leaf = this.app.workspace.getLeaf(true);
    leaf.setViewState({
      type: VIEW_TYPE_WORKSPACE_WEBVIEW,
      state: { url: defaultUrl }
    });
    this.app.workspace.revealLeaf(leaf);
  }
  openCliperView() {
    const leaf = this.app.workspace.getLeaf(true);
    leaf.setViewState({
      type: CLIPPER_VIEW
    });
    this.app.workspace.revealLeaf(leaf);
  }
  showClipModal() {
    new ClipModal(this.app, this.plugin).open();
  }
  async createNewFile() {
    try {
      const timestamp = (/* @__PURE__ */ new Date()).getTime();
      const fileName = `New_Note_${timestamp}.md`;
      const filePath = `${fileName}`;
      const file = await this.app.vault.create(filePath, "");
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian17.MarkdownView);
      if (activeView && activeView.editor) {
        activeView.editor.focus();
      }
    } catch (error) {
      console.error("Error creating new file:", error);
      new import_obsidian17.Notice(`Failed to create new file: ${error.message}`);
    }
  }
  async refreshContent() {
    this.contentEl.empty();
    await this.onOpen();
    this.updateBackgroundImage();
  }
  async onunload() {
    const leafContent = this.containerEl.closest('.workspace-leaf-content[data-type="netclip-home-tab-view"]');
    if (leafContent) {
      leafContent.removeAttribute("style");
    }
  }
};

// src/main.ts
var NetClipPlugin = class extends import_obsidian18.Plugin {
  constructor() {
    super(...arguments);
    this.DEMO_CATEGORIES = ["Articles", "Research", "Tech"];
    this.seenItems = /* @__PURE__ */ new Set();
    this.geminiService = null;
  }
  isNewContent(content) {
    if (this.seenItems.has(content)) {
      return false;
    }
    this.seenItems.add(content);
    return true;
  }
  processContent(content) {
    const lines = content.split("\n");
    const uniqueLines = lines.filter((line) => this.isNewContent(line.trim()));
    return uniqueLines.join("\n");
  }
  initWebViewLeaf() {
    const existingLeaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_WORKSPACE_WEBVIEW);
    if (existingLeaf.length > 0) return;
    const leaf = this.app.workspace.getRightLeaf(false);
    if (leaf) {
      leaf.setViewState({ type: VIEW_TYPE_WORKSPACE_WEBVIEW });
    }
  }
  async FoldersExist() {
    const mainFolderPath = this.settings.parentFolderPath ? `${this.settings.parentFolderPath}/${this.settings.defaultFolderName}` : this.settings.defaultFolderName;
    try {
      if (this.settings.parentFolderPath && !this.app.vault.getFolderByPath(this.settings.parentFolderPath)) {
        try {
          await this.app.vault.createFolder(this.settings.parentFolderPath);
        } catch (error) {
          if (!error.message.includes("already exists")) {
            throw error;
          }
        }
      }
      if (!this.app.vault.getFolderByPath(mainFolderPath)) {
        try {
          await this.app.vault.createFolder(mainFolderPath);
          for (const category of this.DEMO_CATEGORIES) {
            const categoryPath = `${mainFolderPath}/${category}`;
            if (!this.app.vault.getFolderByPath(categoryPath)) {
              try {
                await this.app.vault.createFolder(categoryPath);
                if (!this.settings.categories.includes(category)) {
                  this.settings.categories.push(category);
                }
              } catch (error) {
                if (!error.message.includes("already exists")) {
                  throw error;
                }
              }
            }
          }
          await this.saveSettings();
          new import_obsidian18.Notice(`Created folders in ${mainFolderPath}`);
        } catch (error) {
          if (!error.message.includes("already exists")) {
            throw error;
          }
        }
      }
      for (const category of this.settings.categories) {
        const categoryPath = `${mainFolderPath}/${category}`;
        if (!this.app.vault.getFolderByPath(categoryPath)) {
          try {
            await this.app.vault.createFolder(categoryPath);
          } catch (error) {
            if (!error.message.includes("already exists")) {
              throw error;
            }
          }
        }
      }
    } catch (error) {
      console.error("Error creating folders:", error);
      throw error;
    }
  }
  async onload() {
    await this.loadSettings();
    await this.FoldersExist();
    if (this.settings.geminiApiKey) {
      this.geminiService = new GeminiService(this.settings.geminiApiKey, this.settings);
    }
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const mdLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
        const urlRegex = /(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/g;
        let match;
        let url = null;
        while ((match = mdLinkRegex.exec(line)) !== null) {
          const linkStart = match.index;
          const linkEnd = linkStart + match[0].length;
          if (cursor.ch >= linkStart && cursor.ch <= linkEnd) {
            url = match[2];
            break;
          }
        }
        if (!url) {
          while ((match = urlRegex.exec(line)) !== null) {
            const linkStart = match.index;
            const linkEnd = linkStart + match[0].length;
            if (cursor.ch >= linkStart && cursor.ch <= linkEnd) {
              url = match[0];
              break;
            }
          }
        }
        if (url) {
          menu.addItem((item) => {
            item.setTitle("Open in WebView").setIcon("globe").onClick(async () => {
              const leaf = this.app.workspace.getLeaf(true);
              await leaf.setViewState({
                type: VIEW_TYPE_WORKSPACE_WEBVIEW,
                state: { url }
              });
              this.app.workspace.revealLeaf(leaf);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Open in Modal WebView").setIcon("picture-in-picture-2").onClick(() => {
              new WebViewModal(this.app, url, this).open();
            });
          });
        }
      })
    );
    this.app.workspace.onLayoutReady(() => this.initWebViewLeaf());
    this.contentExtractors = new ContentExtractors(this);
    this.addRibbonIcon("newspaper", "NetClip", async () => this.activateView());
    this.addCommand({
      id: "open-clipper",
      name: "Open clipper",
      callback: () => this.activateView()
    });
    this.addCommand({
      id: "open-modal-clipper",
      name: "Open modal clipper",
      callback: () => new ClipModal(this.app, this).open()
    });
    this.addCommand({
      id: "open-web-editor",
      name: "Open page on editor",
      callback: async () => {
        const leaf = this.app.workspace.getLeaf(true);
        await leaf.setViewState({ type: VIEW_TYPE_WORKSPACE_WEBVIEW, active: true });
        this.app.workspace.revealLeaf(leaf);
      }
    });
    this.addCommand({
      id: "open-web-modal",
      name: "Open page in modal",
      callback: () => {
        const defaultUrl = this.settings.defaultWebUrl || "https://google.com";
        new WebViewModal(this.app, defaultUrl, this).open();
      }
    });
    this.addCommand({
      id: "open-link-in-webview",
      name: "Open link under cursor in WebView",
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const url = this.getLinkUnderCursor(line, cursor.ch);
        if (url) {
          const leaf = this.app.workspace.getLeaf(true);
          leaf.setViewState({
            type: VIEW_TYPE_WORKSPACE_WEBVIEW,
            state: { url }
          });
          this.app.workspace.revealLeaf(leaf);
        } else {
          new import_obsidian18.Notice("No link found under cursor");
        }
      },
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "z" }]
    });
    this.addCommand({
      id: "open-link-in-modal-webview",
      name: "Open link under cursor in Modal WebView",
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const url = this.getLinkUnderCursor(line, cursor.ch);
        if (url) {
          new WebViewModal(this.app, url, this).open();
        } else {
          new import_obsidian18.Notice("No link found under cursor");
        }
      },
      hotkeys: [{ modifiers: ["Ctrl", "Alt"], key: "z" }]
    });
    this.registerView(
      CLIPPER_VIEW,
      (leaf) => new ClipperHomeView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_WORKSPACE_WEBVIEW,
      (leaf) => new WorkspaceLeafWebView(leaf, this)
    );
    this.addSettingTab(new NetClipSettingTab(this.app, this));
    this.registerView(HOME_TAB_VIEW, (leaf) => new HomeTabView(leaf, this));
    this.registerEvent(this.app.workspace.on("layout-change", () => {
      if (this.settings.replaceTabHome) {
        this.replaceTabHome();
      }
    }));
    this.addCommand({
      id: "open-home-tab",
      name: "Open Home Tab",
      callback: () => this.activateHomeTab()
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (this.settings.shortcuts && this.settings.shortcuts.length === 0) {
      const githubShortcut = {
        id: Date.now().toString(),
        name: "",
        url: "https://github.com/Elhary/Obsidian-NetClip",
        favicon: `https://www.google.com/s2/favicons?domain=github.com&sz=128`
      };
      const youtubeShortcut = {
        id: Date.now().toString(),
        name: "",
        url: "https://youtube.com",
        favicon: `https://www.google.com/s2/favicons?domain=youtube.com&sz=128`
      };
      const redditShortcut = {
        id: Date.now().toString(),
        name: "",
        url: "https://www.reddit.com/r/ObsidianMD/",
        favicon: `https://www.google.com/s2/favicons?domain=reddit.com&sz=128`
      };
      const obsidianShortcut = {
        id: Date.now().toString(),
        name: "",
        url: "https://forum.obsidian.md/",
        favicon: `https://www.google.com/s2/favicons?domain=obsidian.md&sz=128`
      };
      this.settings.shortcuts.push(githubShortcut, youtubeShortcut, redditShortcut, obsidianShortcut);
      this.saveSettings();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.updateHomeView();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(CLIPPER_VIEW)[0] || null;
    if (!leaf) {
      switch (this.settings.viewPosition) {
        case "left":
          leaf = workspace.getLeftLeaf(false);
          break;
        case "right":
          leaf = workspace.getRightLeaf(false);
          break;
        default:
          leaf = workspace.getLeaf(false);
      }
    }
    if (leaf) {
      await leaf.setViewState({ type: CLIPPER_VIEW, active: true });
      workspace.revealLeaf(leaf);
    }
  }
  async clipWebpage(url, category = "", selectedPrompt = null, selectedVariables = {}, keepOriginalContent = true) {
    var _a, _b;
    if (!this.contentExtractors) {
      throw new Error("Content extractors not initialized");
    }
    await this.FoldersExist();
    new import_obsidian18.Notice("Clipping...");
    const normalizedUrl = normalizeUrl(url);
    if (!normalizedUrl || !normalizedUrl.startsWith("http")) {
      throw new Error("Invalid URL provided");
    }
    const urlDomain = getDomain(normalizedUrl).toLowerCase();
    let effectiveCategory = category;
    let customSaveLocation = "";
    if (!category) {
      const domainMapping = this.settings.defaultSaveLocations.domainMappings[urlDomain];
      if (domainMapping) {
        customSaveLocation = domainMapping;
      } else if (this.settings.defaultSaveLocations.defaultLocation) {
        customSaveLocation = this.settings.defaultSaveLocations.defaultLocation;
      }
    }
    const response = await (0, import_obsidian18.requestUrl)({
      url: normalizedUrl
    });
    const html = response.text;
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");
    let title = ((_a = doc.querySelector("title")) == null ? void 0 : _a.textContent) || "";
    if (!title) {
      const headingElement = doc.querySelector("h1, .title");
      title = ((_b = headingElement == null ? void 0 : headingElement.textContent) == null ? void 0 : _b.trim()) || `Article from ${getDomain(url)}`;
    }
    title = title.replace(/[#"]/g, "").trim();
    let content = this.contentExtractors.extractMainContent(doc, normalizedUrl);
    const thumbnailUrl = this.contentExtractors.extractThumbnail(doc);
    const author = this.contentExtractors.extractAuthor(doc);
    const desc = this.contentExtractors.extractDescription(doc);
    const publishTime = this.contentExtractors.extractPublishTime(doc);
    const price = this.contentExtractors.extractPrice(doc);
    const brand = this.contentExtractors.extractBrand(doc);
    const rating = this.contentExtractors.extractRating(doc);
    let folderPath;
    if (customSaveLocation) {
      folderPath = customSaveLocation;
    } else if (category) {
      const baseFolderPath = this.settings.parentFolderPath ? `${this.settings.parentFolderPath}/${this.settings.defaultFolderName}` : this.settings.defaultFolderName;
      folderPath = `${baseFolderPath}/${effectiveCategory}`;
    } else {
      folderPath = this.settings.parentFolderPath ? `${this.settings.parentFolderPath}/${this.settings.defaultFolderName}` : this.settings.defaultFolderName;
    }
    if (folderPath && !this.app.vault.getFolderByPath(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
    const wordCount = content.split(/\s+/).length;
    const readingTime = this.calculateReadingTime(wordCount);
    const frontmatter = this.generateFrontmatter(
      title,
      url,
      publishTime,
      author,
      desc,
      readingTime,
      price,
      brand,
      rating,
      thumbnailUrl
    );
    const formattedContent = content.trim().split("\n").map((line) => line.trim()).join("\n");
    const completeNote = `${frontmatter}
${formattedContent}
`;
    let processedContent = completeNote;
    if (this.geminiService && selectedPrompt) {
      processedContent = await this.geminiService.processContent(
        completeNote,
        selectedPrompt,
        selectedVariables,
        keepOriginalContent
      );
      const titleMatch = processedContent.match(/^---[\s\S]*?\ntitle: "([^"]+)"[\s\S]*?\n---/);
      if (titleMatch && titleMatch[1]) {
        title = titleMatch[1];
      }
    }
    const fileName = sanitizePath(`${title}.md`);
    const filePath = folderPath ? `${folderPath}/${fileName}` : fileName;
    await this.app.vault.create(filePath, processedContent);
    await this.updateHomeView();
    new import_obsidian18.Notice(`Successfully clipped ${title}`);
    return filePath;
  }
  calculateReadingTime(wordCount) {
    const min = Math.floor(wordCount / 250);
    const max = Math.ceil(wordCount / 200);
    return min === max ? `${min}` : `${min}~${max}`;
  }
  generateFrontmatter(title, url, publishTime, author, desc, readingTime, price, brand, rating, thumbnailUrl) {
    return `---
title: "${title}"
source: "${url}"
` + (publishTime ? `published: ${new Date(publishTime).toISOString().split("T")[0]}
` : "") + (author ? `author: "${author}"
` : "") + (desc ? `desc: "${desc}"
` : "") + `readingTime: "${readingTime}min"
` + (price ? `price: "${price}"
` : "") + (brand ? `brand: "${brand}"
` : "") + (rating ? `rating: "${rating}"
` : "") + `---

` + (thumbnailUrl ? `![Thumbnail](${thumbnailUrl})

` : "");
  }
  async updateHomeView() {
    const leaves = this.app.workspace.getLeavesOfType(CLIPPER_VIEW);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof ClipperHomeView) {
        const tabsContainer = view.containerEl.querySelector(".netclip_category_tabs");
        if (tabsContainer instanceof HTMLElement) {
          view.renderCategoryTabs(tabsContainer);
        }
        const container = view.containerEl.querySelector(".netclip_saved_container");
        if (container instanceof HTMLDivElement) {
          await view.renderSavedContent(container);
        }
      }
    }
  }
  async processExistingNote(filePath, prompt, variables) {
    if (!this.geminiService) {
      throw new Error("AI service not initialized");
    }
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian18.TFile)) {
      throw new Error("File not found");
    }
    const currentContent = await this.app.vault.read(file);
    const processedContent = await this.geminiService.processContent(
      currentContent,
      prompt,
      variables
    );
    await this.app.vault.modify(file, processedContent);
    new import_obsidian18.Notice(`Successfully processed with ${prompt.name}`);
  }
  getLinkUnderCursor(line, cursorPos) {
    const mdLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
    const urlRegex = /(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/g;
    let match;
    while ((match = mdLinkRegex.exec(line)) !== null) {
      const linkStart = match.index;
      const linkEnd = linkStart + match[0].length;
      if (cursorPos >= linkStart && cursorPos <= linkEnd) {
        return match[2];
      }
    }
    while ((match = urlRegex.exec(line)) !== null) {
      const linkStart = match.index;
      const linkEnd = linkStart + match[0].length;
      if (cursorPos >= linkStart && cursorPos <= linkEnd) {
        return match[0];
      }
    }
    return null;
  }
  replaceTabHome() {
    const emptyLeaves = this.app.workspace.getLeavesOfType("empty");
    if (emptyLeaves.length > 0) {
      emptyLeaves.forEach((leaf) => {
        leaf.setViewState({
          type: HOME_TAB_VIEW
        });
      });
    }
  }
  activateHomeTab() {
    const leaf = this.app.workspace.getLeaf("tab");
    if (leaf) {
      leaf.setViewState({
        type: HOME_TAB_VIEW
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
  refreshHomeViews() {
    this.app.workspace.getLeavesOfType(HOME_TAB_VIEW).forEach((leaf) => {
      if (leaf.view instanceof HomeTabView) {
        leaf.detach();
        const newLeaf = this.app.workspace.getLeaf();
        newLeaf.setViewState({
          type: HOME_TAB_VIEW,
          active: true
        });
      }
    });
  }
};
/*! Bundled license information:

@google/generative-ai/dist/index.mjs:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@google/generative-ai/dist/index.mjs:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/


/* nosourcemap */